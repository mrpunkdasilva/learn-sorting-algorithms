# Learn Sorting Algorithm

## Entendendo Algoritmos de Ordena√ß√£o

Algoritmos de ordena√ß√£o funcionam como organizar uma bagun√ßa - voc√™ pega uma lista desordenada (como an√µes de tamanhos diferentes) e os coloca na ordem correta (do menor para o maior ou vice-versa).

Imagine esta fila de an√µes:

![Fila de an√£o](images/filadeanao.png)

## Conceitos Fundamentais Antes de Come√ßar

Antes de mergulharmos no algoritmo, vamos entender alguns conceitos b√°sicos:

### O que √© um Algoritmo?

Um algoritmo √© simplesmente uma lista de instru√ß√µes passo a passo para resolver um problema. √â como uma receita de bolo - voc√™ segue os passos na ordem certa para chegar ao resultado desejado.

Tip:

Exemplo pr√°tico: Para fazer um sandu√≠che, o algoritmo seria:

1. Pegue duas fatias de p√£o

2. Passe manteiga em uma fatia

3. Coloque o recheio

4. Feche com a outra fatia

### O que √© Itera√ß√£o?

Itera√ß√£o √© quando repetimos um conjunto de passos v√°rias vezes. √â como quando voc√™ escova os dentes - faz o mesmo movimento v√°rias vezes at√© limpar todos os dentes.

Em programa√ß√£o, quando dizemos:

* "Itera√ß√£o 1" = primeira vez que executamos os passos

* "Itera√ß√£o 2" = segunda vez que executamos os passos

* E assim por diante...

### O que √© Compara√ß√£o?

Comparar √© verificar qual elemento √© maior, menor ou igual ao outro. √â como quando voc√™ compara a altura de duas pessoas para saber quem √© mais alto.

## O B√°sico do Algoritmo de Ordena√ß√£o

Nosso algoritmo simples compara os elementos um a um, como quando voc√™ organiza suas roupas - pega cada pe√ßa e compara com as outras para ver qual √© maior ou menor.

## Como Funciona na Pr√°tica

Agora vamos ver como o algoritmo trabalha itera√ß√£o por itera√ß√£o (ou seja, repeti√ß√£o por repeti√ß√£o):

### Primeira Itera√ß√£o (1¬™ Repeti√ß√£o)

Comparo o primeiro an√£o ($i_1$) com o segundo an√£o ($j_1$).

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: Sim (verdadeiro) ‚Üí N√£o preciso trocar nada!

![Primeira itera√ß√£o](images/Primeiraiteracao.png)

### Segunda Itera√ß√£o (2¬™ Repeti√ß√£o)

Agora comparo $i_2$ com $j_2$.

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: N√£o (falso) ‚Üí Preciso trocar eles de lugar!

![Segunda itera√ß√£o](images/segundaint.png)

### Terceira Itera√ß√£o (3¬™ Repeti√ß√£o)

Comparo $i_{3}$ com $j_{3}$.

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: Sim (verdadeiro) ‚Üí N√£o preciso trocar nada!

![Terceira itera√ß√£o](images/terceiraint.png)

### Quarta Itera√ß√£o (4¬™ Repeti√ß√£o)

Comparo $i_{4}$ com $j_{4}$.

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: N√£o (falso) ‚Üí Preciso trocar eles de lugar!

![Quarta itera√ß√£o](images/quartaiteracao.png)

### Quinta Itera√ß√£o (5¬™ e √öltima Repeti√ß√£o)

Agora todos os elementos j√° est√£o na ordem correta!

![Quinta intera√ß√£o](images/quintainteracao.png)
Tip:

Resumo: A cada itera√ß√£o, fazemos uma pergunta (compara√ß√£o) e tomamos uma decis√£o (trocar ou n√£o trocar). Repetimos isso at√© que tudo esteja organizado!

## O Que Todo Algoritmo de Ordena√ß√£o Precisa

Resumindo, todo algoritmo de ordena√ß√£o possui:

1. Entrada: A lista desordenada

2. Tipo de ordem: Crescente ou decrescente

3. Itera√ß√µes: Quantidade de repeti√ß√µes do processo

4. Compara√ß√µes: Crit√©rio para comparar os elementos

5. Sa√≠da: A lista organizada

```MERMAID
graph TD
    A[Algoritmo] --> B[Lista desordenada]
    A --> C[Ordem crescente/decrescente]
    A --> D[Repeti√ß√µes necess√°rias]
    A --> E[Como comparar]
    A --> F[Lista ordenada]
```

## Partindo para o C√≥digo

Agora vamos ver como transformar nossa l√≥gica em c√≥digo C++. Vou explicar cada parte:

### Conceitos B√°sicos Antes do C√≥digo

#### O que √© um Array?

Um array √© como uma fileira de caixas numeradas onde guardamos valores. Cada caixa tem um n√∫mero (√≠ndice) e pode guardar um valor.

```
Array: [5] [2] [8] [1] [9]
√çndice: 0   1   2   3   4
```

#### O que √© um Loop For?

Um loop for √© uma forma de repetir uma a√ß√£o v√°rias vezes. √â como dizer: "fa√ßa isso 10 vezes" ou "fa√ßa isso para cada elemento da lista".

```CPLUSPLUS
for (int i = 0; i < 5; i++) {
    // Este c√≥digo vai executar 5 vezes
    // i vai valer: 0, 1, 2, 3, 4
}
```

### O C√≥digo Completo Explicado

```CPLUSPLUS
#include <iostream>  // Para usar cout e cin (entrada e sa√≠da)
#include <cstdlib>   // Para usar rand() (n√∫meros aleat√≥rios)
#define MAX_SIZE 100 // Define o tamanho m√°ximo do array
using namespace std;

int main()
{
    // PARTE 1: DECLARA√á√ÉO DAS VARI√ÅVEIS
    int n;                // Quantos n√∫meros vamos ordenar
    int array[MAX_SIZE];  // Nossa lista de n√∫meros (o array)

    // PARTE 2: ENTRADA DE DADOS
    cout << "Digite quantos n√∫meros voc√™ quer ordenar: " << endl;
    cin >> n;  // L√™ a resposta do usu√°rio

    // PARTE 3: PREENCHIMENTO COM N√öMEROS ALEAT√ìRIOS
    cout << "Gerando " << n << " n√∫meros aleat√≥rios..." << endl;
    for (int i = 0; i < n; i++) {
        array[i] = rand() % 100;  // Gera n√∫mero entre 0 e 99
    }

    // PARTE 4: MOSTRA A LISTA BAGUN√áADA
    cout << "\nLista original (bagun√ßada): ";
    for (int i = 0; i < n; i++) {
        cout << "[" << array[i] << "] ";
    }
    cout << endl << endl;

    // PARTE 5: O ALGORITMO DE ORDENA√á√ÉO (O CORA√á√ÉO DO PROGRAMA!)
    cout << "Iniciando ordena√ß√£o..." << endl;
    
    // Loop externo: seleciona cada elemento (itera√ß√£o principal)
    for (int i = 0; i < n; i++) {
        
        // Loop interno: compara com os elementos seguintes
        for (int j = i + 1; j < n; j++) {
            
            // Mostra o que est√° sendo comparado
            cout << "Comparando: " << array[i] << " com " << array[j];
            
            // AQUI √â ONDE A M√ÅGICA ACONTECE!
            // Se o primeiro for MENOR que o segundo, trocamos
            if (array[i] < array[j]) {
                cout << " ‚Üí Trocando!" << endl;
                
                // PROCESSO DE TROCA (como trocar duas cartas de lugar)
                int temp = array[i];  // Guarda o primeiro valor
                array[i] = array[j];  // P√µe o segundo no lugar do primeiro
                array[j] = temp;      // P√µe o primeiro no lugar do segundo
            } else {
                cout << " ‚Üí N√£o precisa trocar" << endl;
            }
        }
    }

    // PARTE 6: MOSTRA O RESULTADO FINAL
    cout << "\n" << "=" << endl;
    cout << "Lista ordenada (maior para menor): ";
    for (int i = 0; i < n; i++) {
        cout << "[" << array[i] << "] ";
    }
    cout << endl;

    return 0;  // Programa terminou com sucesso
}
```

### Pontos Importantes Para Entender:

#### 

1. Como Funciona o rand()

* `rand()` gera n√∫meros aleat√≥rios gigantes

* `rand() % 100` limita os n√∫meros entre 0 e 99 (mais f√°cil de trabalhar)

#### 

2. Por que Dois Loops For?

* Loop externo (i): Escolhe cada elemento da lista, um por vez

* Loop interno (j): Compara esse elemento com todos os outros que v√™m depois

* √â como comparar cada an√£o com todos os outros an√µes

#### 

3. Como Funciona a Troca (Swap)?

Imagine que voc√™ tem duas cartas e quer trocar elas de lugar:

```CPLUSPLUS
int temp = array[i];  // Guardo a primeira carta na m√£o
array[i] = array[j];  // Ponho a segunda carta no lugar da primeira
array[j] = temp;      // Ponho a primeira carta (que estava na m√£o) no lugar da segunda
```

#### 

4. Mudando a Ordem

* Para ordem DECRESCENTE (maior ‚Üí menor): use `if (array[i] < array[j])`

* Para ordem CRESCENTE (menor ‚Üí maior): use `if (array[i] > array[j])`

### Importante Saber

Este algoritmo se chama Selection Sort (Ordena√ß√£o por Sele√ß√£o). Ele n√£o √© o mais r√°pido para listas muito grandes, mas √© perfeito para aprender porque:

* ‚úÖ √â f√°cil de entender

* ‚úÖ Mostra claramente como funciona a ordena√ß√£o

* ‚úÖ Usa conceitos b√°sicos que voc√™ vai usar sempre

Tip:

Dica: Execute o c√≥digo algumas vezes com n√∫meros pequenos (como 5 elementos) para ver exatamente como ele funciona!



# Selection Sort

## O que √© Selection Sort?

O Selection Sort √© um algoritmo de ordena√ß√£o simples e intuitivo que funciona dividindo o array em duas partes:

* Parte ordenada: Localizada no in√≠cio do array (inicialmente vazia)

* Parte n√£o ordenada: Localizada no final do array (inicialmente todo o array)

## Como funciona?

O algoritmo funciona da seguinte forma:

1. Encontra o menor elemento da parte n√£o ordenada

2. Troca esse elemento com o primeiro elemento da parte n√£o ordenada

3. Expande a parte ordenada em uma posi√ß√£o

4. Repete o processo at√© que todo o array esteja ordenado

## Diagrama√ß√£o

![selectionSort_annotated.png](images/selectionSort_annotated.png)

## Exemplo Visual

Considerando o array: `[64, 25, 12, 22, 11]`

Itera√ß√£o 1:

* Parte ordenada: `[]`

* Parte n√£o ordenada: `[64, 25, 12, 22, 11]`

* Menor elemento: `11` (posi√ß√£o 4)

* Troca: `11` ‚Üî `64`

* Resultado: `[11, 25, 12, 22, 64]`

Itera√ß√£o 2:

* Parte ordenada: `[11]`

* Parte n√£o ordenada: `[25, 12, 22, 64]`

* Menor elemento: `12` (posi√ß√£o 2)

* Troca: `12` ‚Üî `25`

* Resultado: `[11, 12, 25, 22, 64]`

Itera√ß√£o 3:

* Parte ordenada: `[11, 12]`

* Parte n√£o ordenada: `[25, 22, 64]`

* Menor elemento: `22` (posi√ß√£o 3)

* Troca: `22` ‚Üî `25`

* Resultado: `[11, 12, 22, 25, 64]`

Itera√ß√£o 4:

* Parte ordenada: `[11, 12, 22]`

* Parte n√£o ordenada: `[25, 64]`

* Menor elemento: `25` (j√° na posi√ß√£o correta)

* Sem troca necess√°ria

* Resultado: `[11, 12, 22, 25, 64]`



# Implementa√ß√£o

Nossa implementa√ß√£o educativa inclui sa√≠das detalhadas para ajudar no aprendizado.

Voc√™ pode encontrar uma implementa√ß√£o completa e educativa do Selection Sort em:

## Fun√ß√£o Principal - Selection Sort Algorithm

```CPP
void selectionSortAlgorithm(int dataArray[], int arraySize)
{
    cout << "========================================" << endl;
    cout << "STARTING SELECTION SORT ALGORITHM" << endl;
    cout << "========================================" << endl;
    cout << "Initial array: ";
    for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
        cout << dataArray[displayIndex] << " ";
    }
    cout << endl << endl;

    int totalNumberOfSwaps = 0;

    for (int currentPosition = 0; currentPosition < arraySize - 1; currentPosition++)
    {
        cout << ">>> ITERATION " << (currentPosition + 1) << " <<<" << endl;
        cout << "Looking for smallest element for position " << currentPosition << endl;
        
        int smallestElementIndex = findSmallestElementIndex(dataArray, currentPosition, arraySize - 1);

        if (currentPosition != smallestElementIndex) {
            cout << "Smallest element is at position " << smallestElementIndex << ", need to swap with position " << currentPosition << endl;
            swapElements(dataArray, currentPosition, smallestElementIndex);
            totalNumberOfSwaps++;
        } else {
            cout << "Smallest element is already in correct position (" << currentPosition << "), no swap needed" << endl;
        }

        cout << "Array state after iteration " << (currentPosition + 1) << ": ";
        for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
            if (displayIndex <= currentPosition) {
                cout << "[" << dataArray[displayIndex] << "] "; // Already sorted elements
            } else {
                cout << dataArray[displayIndex] << " ";        // Not yet sorted elements
            }
        }
        cout << endl;
        cout << "Elements sorted: " << (currentPosition + 1) << "/" << arraySize << endl;
        cout << "--------------------------------" << endl;
    }

    cout << "========================================" << endl;
    cout << "SELECTION SORT ALGORITHM COMPLETED!" << endl;
    cout << "Total number of swaps performed: " << totalNumberOfSwaps << endl;
    cout << "========================================" << endl;
}
```

## Fun√ß√£o para Encontrar o Menor Elemento

```CPP
int findSmallestElementIndex(int dataArray[], int startIndex, int endIndex)
{
    cout << "--- Searching for smallest element in range [" << startIndex << ", " << endIndex << "] ---" << endl;
    int currentIndex = startIndex;
    int smallestIndex = currentIndex;
    int numberOfComparisons = 0;

    cout << "Initial element for comparison: dataArray[" << smallestIndex << "] = " << dataArray[smallestIndex] << endl;

    while (currentIndex <= endIndex)
    {
        cout << "Comparing dataArray[" << currentIndex << "] = " << dataArray[currentIndex] << " with current smallest dataArray[" << smallestIndex << "] = " << dataArray[smallestIndex];
        numberOfComparisons++;
        
        if (dataArray[currentIndex] < dataArray[smallestIndex])
        {
            cout << " -> " << dataArray[currentIndex] << " is smaller! New smallest element found at position " << currentIndex << endl;
            smallestIndex = currentIndex;
        }
        else
        {
            cout << " -> " << dataArray[currentIndex] << " >= " << dataArray[smallestIndex] << ", keeping current smallest" << endl;
        }

        currentIndex++;
    }

    cout << "Smallest element found: " << dataArray[smallestIndex] << " at position " << smallestIndex << " (after " << numberOfComparisons << " comparisons)" << endl;
    return smallestIndex;
}
```

## Fun√ß√£o para Trocar Elementos

```CPP
void swapElements(int dataArray[], int firstPosition, int secondPosition)
{
    cout << "  -> Swapping elements: " << dataArray[firstPosition] << " (position " << firstPosition << ") <-> " << dataArray[secondPosition] << " (position " << secondPosition << ")" << endl;
    int temporaryValue = dataArray[firstPosition];
    dataArray[firstPosition] = dataArray[secondPosition];
    dataArray[secondPosition] = temporaryValue;
    cout << "  -> After swap: position " << firstPosition << " = " << dataArray[firstPosition] << ", position " << secondPosition << " = " << dataArray[secondPosition] << endl;
}
```

## Caracter√≠sticas do Algoritmo

### Complexidade de Tempo

* Melhor caso: O(n¬≤) - Mesmo que o array j√° esteja ordenado

* Caso m√©dio: O(n¬≤) - Comportamento t√≠pico

* Pior caso: O(n¬≤) - Array ordenado inversamente

### Complexidade de Espa√ßo

* O(1) - Algoritmo in-place, usa apenas mem√≥ria constante adicional

### Propriedades Importantes

| Propriedade |Valor |
----------------------
| Est√°vel |‚ùå N√£o |
| In-place |‚úÖ Sim |
| Adaptivo |‚ùå N√£o |
| Compara√ß√µes |O(n¬≤) |
| Trocas |O(n) |



# Vantagens vs. Disvantagens

## Vantagens

* ‚úÖ Simples de implementar e entender

* ‚úÖ Poucas trocas: M√°ximo de n-1 trocas

* ‚úÖ In-place: N√£o requer mem√≥ria adicional

* ‚úÖ Funciona bem com arrays pequenos

* ‚úÖ Eficiente quando opera√ß√µes de escrita s√£o caras

## Desvantagens

* ‚ùå Complexidade O(n¬≤): Ineficiente para arrays grandes

* ‚ùå N√£o √© est√°vel: Pode alterar a ordem relativa de elementos iguais

* ‚ùå N√£o √© adaptivo: N√£o aproveita arrays parcialmente ordenados

* ‚ùå Sempre faz n-1 passadas: Mesmo que o array j√° esteja ordenado



# Compara√ß√£o com Outros Algoritmos

| Algoritmo |Melhor Caso |Caso M√©dio |Pior Caso |Est√°vel |Trocas |
------------------------------------------------------------------
| Selection Sort |O(n¬≤) |O(n¬≤) |O(n¬≤) |‚ùå |O(n) |
| Bubble Sort |O(n) |O(n¬≤) |O(n¬≤) |‚úÖ |O(n¬≤) |
| Insertion Sort |O(n) |O(n¬≤) |O(n¬≤) |‚úÖ |O(n¬≤) |
| Merge Sort |O(n log n) |O(n log n) |O(n log n) |‚úÖ |- |
| Quick Sort |O(n log n) |O(n log n) |O(n¬≤) |‚ùå |O(n log n) |



# Varia√ß√µes do Selection Sort

## 1. Selection Sort Bidirecional

Encontra simultaneamente o menor e maior elemento em cada passada, colocando-os nas extremidades.

## 2. Selection Sort Recursivo

Implementa√ß√£o recursiva que ordena recursivamente subarray ap√≥s colocar o menor elemento na primeira posi√ß√£o.

## 3. Selection Sort Est√°vel

Modifica√ß√£o que mant√©m a estabilidade trocando elementos apenas quando necess√°rio.



# Conclus√£o

O Selection Sort √© um excelente algoritmo para aprender os conceitos de ordena√ß√£o devido √† sua simplicidade e l√≥gica intuitiva. Embora n√£o seja eficiente para arrays grandes, tem seu lugar em situa√ß√µes espec√≠ficas onde a simplicidade e o baixo n√∫mero de trocas s√£o importantes.

O algoritmo demonstra claramente os conceitos de:

* Divis√£o de problema em subproblemas

* Invariantes de loop

* An√°lise de complexidade

* Trade-offs entre diferentes m√©tricas de performance



# Implementa√ß√£o

Nossa implementa√ß√£o educativa inclui sa√≠das detalhadas para ajudar no aprendizado.

Voc√™ pode encontrar uma implementa√ß√£o completa e educativa do Bubble Sort em:

[* üìÅ `Domus/Domus-1/bubbleSort.cpp`](resources/bubbleSort.cpp)

## Fun√ß√£o Principal - Bubble Sort Algorithm

```CPP
void bubbleSortAlgorithm(int dataArray[], int arraySize)
{
    cout << "========================================" << endl;
    cout << "STARTING BUBBLE SORT ALGORITHM" << endl;
    cout << "========================================" << endl;
    cout << "Initial array: ";
    for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
        cout << dataArray[displayIndex] << " ";
    }
    cout << endl << endl;

    int totalNumberOfSwaps = 0;
    int totalNumberOfComparisons = 0;
    bool hasSwapped = true;
    int iterationCount = 0;

    while (hasSwapped && iterationCount < arraySize - 1)
    {
        iterationCount++;
        hasSwapped = false;
        
        cout << ">>> ITERATION " << iterationCount << " <<<" << endl;
        cout << "Comparing adjacent elements..." << endl;
        
        for (int currentIndex = 0; currentIndex < arraySize - iterationCount; currentIndex++)
        {
            int nextIndex = currentIndex + 1;
            totalNumberOfComparisons++;
            
            cout << "Comparing dataArray[" << currentIndex << "] = " << dataArray[currentIndex] 
                 << " with dataArray[" << nextIndex << "] = " << dataArray[nextIndex];
            
            if (dataArray[currentIndex] > dataArray[nextIndex]) {
                cout << " -> " << dataArray[currentIndex] << " > " << dataArray[nextIndex] 
                     << ", need to swap!" << endl;
                swapElements(dataArray, currentIndex, nextIndex);
                hasSwapped = true;
                totalNumberOfSwaps++;
            } else {
                cout << " -> " << dataArray[currentIndex] << " <= " << dataArray[nextIndex] 
                     << ", no swap needed" << endl;
            }
        }

        cout << "Array state after iteration " << iterationCount << ": ";
        for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
            if (displayIndex >= arraySize - iterationCount) {
                cout << "[" << dataArray[displayIndex] << "] "; // Already sorted elements
            } else {
                cout << dataArray[displayIndex] << " ";        // Not yet sorted elements
            }
        }
        cout << endl;
        cout << "Elements in final position: " << iterationCount << "/" << arraySize << endl;
        
        if (!hasSwapped) {
            cout << "No swaps performed in this iteration - array is sorted!" << endl;
        }
        cout << "--------------------------------" << endl;
    }

    cout << "========================================" << endl;
    cout << "BUBBLE SORT ALGORITHM COMPLETED!" << endl;
    cout << "Total number of iterations: " << iterationCount << endl;
    cout << "Total number of comparisons: " << totalNumberOfComparisons << endl;
    cout << "Total number of swaps performed: " << totalNumberOfSwaps << endl;
    cout << "========================================" << endl;
}
```

## Fun√ß√£o para Trocar Elementos

```CPP
void swapElements(int dataArray[], int firstPosition, int secondPosition)
{
    cout << "  -> Swapping elements: " << dataArray[firstPosition] << " (position " << firstPosition << ") <-> " << dataArray[secondPosition] << " (position " << secondPosition << ")" << endl;
    int temporaryValue = dataArray[firstPosition];
    dataArray[firstPosition] = dataArray[secondPosition];
    dataArray[secondPosition] = temporaryValue;
    cout << "  -> After swap: position " << firstPosition << " = " << dataArray[firstPosition] << ", position " << secondPosition << " = " << dataArray[secondPosition] << endl;
}
```

## Vers√£o Otimizada do Bubble Sort

```CPP
void optimizedBubbleSortAlgorithm(int dataArray[], int arraySize)
{
    cout << "========================================" << endl;
    cout << "STARTING OPTIMIZED BUBBLE SORT ALGORITHM" << endl;
    cout << "========================================" << endl;
    
    int totalNumberOfSwaps = 0;
    int totalNumberOfComparisons = 0;
    
    for (int iteration = 0; iteration < arraySize - 1; iteration++)
    {
        bool hasSwapped = false;
        
        cout << ">>> ITERATION " << (iteration + 1) << " <<<" << endl;
        
        for (int currentIndex = 0; currentIndex < arraySize - iteration - 1; currentIndex++)
        {
            totalNumberOfComparisons++;
            
            if (dataArray[currentIndex] > dataArray[currentIndex + 1]) {
                swapElements(dataArray, currentIndex, currentIndex + 1);
                hasSwapped = true;
                totalNumberOfSwaps++;
            }
        }
        
        // Early termination if no swaps occurred
        if (!hasSwapped) {
            cout << "No swaps in this iteration - array is already sorted!" << endl;
            break;
        }
        
        cout << "Array after iteration " << (iteration + 1) << ": ";
        for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
            cout << dataArray[displayIndex] << " ";
        }
        cout << endl << "--------------------------------" << endl;
    }
    
    cout << "Total comparisons: " << totalNumberOfComparisons << endl;
    cout << "Total swaps: " << totalNumberOfSwaps << endl;
}
```

## Caracter√≠sticas do Algoritmo

### Complexidade de Tempo

* Melhor caso: O(n) - Array j√° ordenado (com otimiza√ß√£o)

* Caso m√©dio: O(n¬≤) - Comportamento t√≠pico

* Pior caso: O(n¬≤) - Array ordenado inversamente

### Complexidade de Espa√ßo

* O(1) - Algoritmo in-place, usa apenas mem√≥ria constante adicional

### Propriedades Importantes

| Propriedade |Valor |
----------------------
| Est√°vel |‚úÖ Sim |
| In-place |‚úÖ Sim |
| Adaptivo |‚úÖ Sim (com otimiza√ß√£o) |
| Compara√ß√µes |O(n¬≤) |
| Trocas |O(n¬≤) |



# Por que o Bubble Sort √â Est√°vel?

## O que significa "Estabilidade" em algoritmos de ordena√ß√£o?

Um algoritmo de ordena√ß√£o √© est√°vel quando mant√©m a ordem relativa dos elementos que possuem valores iguais. Ou seja, se dois elementos t√™m o mesmo valor, aquele que aparece primeiro no array original deve aparecer primeiro no array ordenado.

## Exemplo Pr√°tico de Estabilidade

Considere um array de cartas onde cada carta tem um valor e um naipe:

Array inicial: `[5‚ô†, 3‚ô¶, 5‚ô•, 2‚ô£, 3‚ô†]`

Vamos ordenar por valor num√©rico apenas, ignorando o naipe:

### ‚úÖ Bubble Sort (est√°vel):

`[2‚ô£, 3‚ô¶, 3‚ô†, 5‚ô†, 5‚ô•]`

* Note que `3‚ô¶` vem antes de `3‚ô†` (mant√©m ordem original)

* E `5‚ô†` vem antes de `5‚ô•` (mant√©m ordem original)

## Por que o Bubble Sort mant√©m a estabilidade?

O Bubble Sort mant√©m a estabilidade porque:

1. Compara apenas elementos adjacentes

2. S√≥ troca elementos se o da esquerda for MAIOR que o da direita

3. Nunca troca elementos iguais

### Demonstra√ß√£o com n√∫meros simples:

Array: `[4, 2a, 2b, 1]` (onde 2a e 2b t√™m o mesmo valor, mas origens diferentes)

Itera√ß√£o 1:

* Compara 4 e 2a: `4 > 2a` ‚Üí Troca: `[2a, 4, 2b, 1]`

* Compara 4 e 2b: `4 > 2b` ‚Üí Troca: `[2a, 2b, 4, 1]`

* Compara 4 e 1: `4 > 1` ‚Üí Troca: `[2a, 2b, 1, 4]`

Itera√ß√£o 2:

* Compara 2a e 2b: `2a == 2b` ‚Üí Sem troca (preserva ordem!)

* Compara 2b e 1: `2b > 1` ‚Üí Troca: `[2a, 1, 2b, 4]`

Itera√ß√£o 3:

* Compara 2a e 1: `2a > 1` ‚Üí Troca: `[1, 2a, 2b, 4]`

Resultado final: `[1, 2a, 2b, 4]` ‚úÖ Ordem original mantida!

## Exemplo Pr√°tico com Dados Reais

```CPP
struct Pessoa {
    string nome;
    int idade;
    int numeroChegada; // Para identificar ordem original
};

// Array inicial (ordenado por chegada):
// 1. Jo√£o, 25 anos
// 2. Maria, 30 anos  
// 3. Pedro, 25 anos
// 4. Ana, 20 anos

// Ap√≥s Bubble Sort por idade:
// 1. Ana, 20 anos
// 2. Jo√£o, 25 anos     <- Jo√£o mant√©m prioridade sobre Pedro
// 3. Pedro, 25 anos    <- Pedro vem depois (ordem original preservada)
// 4. Maria, 30 anos
```

## Import√¢ncia da Estabilidade

A estabilidade √© crucial quando:

* Ordena√ß√£o m√∫ltipla: Primeiro por um campo, depois por outro

* Preserva√ß√£o de contexto: Manter informa√ß√µes sobre ordem original

* Interfaces de usu√°rio: Comportamento previs√≠vel para o usu√°rio

* Dados com metadados: Timestamps, IDs, etc.

## Compara√ß√£o com Algoritmos Inst√°veis

| Algoritmo |Est√°vel? |Motivo |
-------------------------------
| Bubble Sort |‚úÖ Sim |S√≥ troca adjacentes se forem diferentes |
| Selection Sort |‚ùå N√£o |Troca elementos distantes |
| Insertion Sort |‚úÖ Sim |Insere mantendo ordem |
| Quick Sort |‚ùå N√£o |Particionamento pode alterar ordem |
| Merge Sort |‚úÖ Sim |Merge preserva ordem quando iguais |

## Implementa√ß√£o que Garante Estabilidade

```CPP
void stableBubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = 0; j < n - i - 1; j++) {
            // CRUCIAL: usar > e n√£o >=
            if (arr[j] > arr[j + 1]) {  // N√£o troca elementos iguais!
                swap(arr[j], arr[j + 1]);
            }
        }
    }
}
```

Note:

üîë Ponto-chave: Use `>` (maior que) e nunca `>=` (maior ou igual) na condi√ß√£o de troca para manter a estabilidade!



# Quando Usar?

O Bubble Sort √© adequado quando:

* Arrays muito pequenos (< 10 elementos)

* Estabilidade √© crucial (manter ordem relativa de elementos iguais)

* Detec√ß√£o de ordena√ß√£o √© importante (pode parar cedo se j√° ordenado)

* Fins educacionais (aprender conceitos de ordena√ß√£o)

* Simplicidade extrema √© mais importante que efici√™ncia

* Prot√≥tipos r√°pidos onde performance n√£o √© cr√≠tica



# Compara√ß√£o com Outros Algoritmos

| Algoritmo |Melhor Caso |Caso M√©dio |Pior Caso |Est√°vel |Trocas |
------------------------------------------------------------------
| Bubble Sort |O(n) |O(n¬≤) |O(n¬≤) |‚úÖ |O(n¬≤) |
| Selection Sort |O(n¬≤) |O(n¬≤) |O(n¬≤) |‚ùå |O(n) |
| Insertion Sort |O(n) |O(n¬≤) |O(n¬≤) |‚úÖ |O(n¬≤) |
| Merge Sort |O(n log n) |O(n log n) |O(n log n) |‚úÖ |- |
| Quick Sort |O(n log n) |O(n log n) |O(n¬≤) |‚ùå |O(n log n) |



# Varia√ß√µes do Bubble Sort

## 1. Bubble Sort Otimizado (com Flag)

Adiciona uma flag para detectar quando o array j√° est√° ordenado e para antecipadamente.

```CPP
void optimizedBubbleSort(int arr[], int n) {
    for (int i = 0; i < n - 1; i++) {
        bool hasSwapped = false;
        
        for (int j = 0; j < n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                hasSwapped = true;
            }
        }
        
        // Se n√£o houve trocas, array est√° ordenado
        if (!hasSwapped) {
            break;
        }
    }
}
```

## 2. Cocktail Sort (Bubble Sort Bidirecional)

Funciona em ambas as dire√ß√µes alternadamente, melhorando a performance em alguns casos.

```CPP
void cocktailSort(int arr[], int n) {
    bool hasSwapped = true;
    int start = 0;
    int end = n - 1;
    
    while (hasSwapped) {
        hasSwapped = false;
        
        // Esquerda para direita
        for (int i = start; i < end; i++) {
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                hasSwapped = true;
            }
        }
        end--;
        
        if (!hasSwapped) break;
        
        // Direita para esquerda
        for (int i = end; i > start; i--) {
            if (arr[i] < arr[i - 1]) {
                swap(arr[i], arr[i - 1]);
                hasSwapped = true;
            }
        }
        start++;
    }
}
```

## 3. Bubble Sort Recursivo

Implementa√ß√£o recursiva que "borbulha" o maior elemento e ordena recursivamente o restante.

```CPP
void recursiveBubbleSort(int arr[], int n) {
    // Caso base
    if (n == 1) return;
    
    // Uma passada para colocar o maior elemento no final
    for (int i = 0; i < n - 1; i++) {
        if (arr[i] > arr[i + 1]) {
            swap(arr[i], arr[i + 1]);
        }
    }
    
    // Chama recursivamente para os primeiros n-1 elementos
    recursiveBubbleSort(arr, n - 1);
}
```

## 4. Odd-Even Sort (Brick Sort)

Varia√ß√£o que compara elementos em posi√ß√µes √≠mpares/pares alternadamente.

```CPP
void oddEvenSort(int arr[], int n) {
    bool isSorted = false;
    
    while (!isSorted) {
        isSorted = true;
        
        // Compara elementos em posi√ß√µes √≠mpares
        for (int i = 1; i <= n - 2; i += 2) {
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                isSorted = false;
            }
        }
        
        // Compara elementos em posi√ß√µes pares
        for (int i = 0; i <= n - 2; i += 2) {
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                isSorted = false;
            }
        }
    }
}
```



# Exerc√≠cios Pr√°ticos

## Exerc√≠cio 1: Implementa√ß√£o B√°sica

Implemente o Bubble Sort para ordenar um array de strings por ordem alfab√©tica.

### üí° Solu√ß√£o do Exerc√≠cio 1

[C√≥digo completo](resources/bubbleSortString.cpp)

```CPP
#include <iostream>
#include <string>
using namespace std;

// Fun√ß√£o para trocar duas strings
void swapStrings(string arr[], int pos1, int pos2) {
    cout << "  -> Trocando \"" << arr[pos1] << "\" com \"" << arr[pos2] << "\"" << endl;
    string temp = arr[pos1];
    arr[pos1] = arr[pos2];
    arr[pos2] = temp;
}

// Bubble Sort para strings
void bubbleSortStrings(string arr[], int size) {
    cout << "Ordenando strings por ordem alfab√©tica usando Bubble Sort:" << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "\n>>> ITERA√á√ÉO " << (i + 1) << " <<<" << endl;
        bool hasSwapped = false;
        
        for (int j = 0; j < size - i - 1; j++) {
            cout << "Comparando \"" << arr[j] << "\" com \"" << arr[j + 1] << "\"";
            
            if (arr[j] > arr[j + 1]) {
                cout << " -> \"" << arr[j] << "\" > \"" << arr[j + 1] << "\", precisa trocar!" << endl;
                swapStrings(arr, j, j + 1);
                hasSwapped = true;
            } else {
                cout << " -> \"" << arr[j] << "\" <= \"" << arr[j + 1] << "\", sem troca" << endl;
            }
        }
        
        cout << "Array ap√≥s itera√ß√£o " << (i + 1) << ": ";
        for (int k = 0; k < size; k++) {
            if (k >= size - i - 1) {
                cout << "[\"" << arr[k] << "\"] ";
            } else {
                cout << "\"" << arr[k] << "\" ";
            }
        }
        cout << endl;
        
        if (!hasSwapped) {
            cout << "Nenhuma troca realizada - array j√° est√° ordenado!" << endl;
            break;
        }
    }
}

int main() {
    const int SIZE = 6;
    string nomes[SIZE] = {"Maria", "Jo√£o", "Ana", "Pedro", "Carlos", "Beatriz"};
    
    cout << "Array inicial: ";
    for (int i = 0; i < SIZE; i++) {
        cout << "\"" << nomes[i] << "\" ";
    }
    cout << endl << endl;
    
    bubbleSortStrings(nomes, SIZE);
    
    cout << "\n========================================" << endl;
    cout << "RESULTADO FINAL:" << endl;
    cout << "Array ordenado: ";
    for (int i = 0; i < SIZE; i++) {
        cout << "\"" << nomes[i] << "\" ";
    }
    cout << endl;
    cout << "========================================" << endl;
    
    return 0;
}
```

## Exerc√≠cio 2: Bubble Sort com Contador de Opera√ß√µes

Modifique o algoritmo Bubble Sort para contar e exibir o n√∫mero total de compara√ß√µes e trocas realizadas.

### üí° Solu√ß√£o do Exerc√≠cio 2

[C√≥digo completo](resources/bubbleWithStats.cpp)

```CPP
#include <iostream>
using namespace std;

struct BubbleSortStats {
    int comparisons;
    int swaps;
    int iterations;
};

void bubbleSortWithStats(int arr[], int size, BubbleSortStats& stats) {
    stats.comparisons = 0;
    stats.swaps = 0;
    stats.iterations = 0;
    
    cout << "Bubble Sort com estat√≠sticas detalhadas:" << endl;
    
    for (int i = 0; i < size - 1; i++) {
        stats.iterations++;
        cout << "\n>>> ITERA√á√ÉO " << stats.iterations << " <<<" << endl;
        bool hasSwapped = false;
        
        for (int j = 0; j < size - i - 1; j++) {
            stats.comparisons++;
            cout << "Compara√ß√£o " << stats.comparisons << ": " << arr[j] << " vs " << arr[j + 1];
            
            if (arr[j] > arr[j + 1]) {
                // Realizar troca
                int temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
                
                stats.swaps++;
                hasSwapped = true;
                cout << " -> Troca " << stats.swaps << " realizada!" << endl;
            } else {
                cout << " -> Sem troca necess√°ria" << endl;
            }
        }
        
        cout << "Array ap√≥s itera√ß√£o " << stats.iterations << ": ";
        for (int k = 0; k < size; k++) {
            cout << arr[k] << " ";
        }
        cout << endl;
        
        if (!hasSwapped) {
            cout << "Otimiza√ß√£o: Array j√° ordenado, parando antecipadamente!" << endl;
            break;
        }
    }
}

int main() {
    int numeros[] = {64, 34, 25, 12, 22, 11, 90};
    int tamanho = sizeof(numeros) / sizeof(numeros[0]);
    BubbleSortStats estatisticas;
    
    cout << "Array inicial: ";
    for (int i = 0; i < tamanho; i++) {
        cout << numeros[i] << " ";
    }
    cout << endl;
    
    bubbleSortWithStats(numeros, tamanho, estatisticas);
    
    cout << "\n========================================" << endl;
    cout << "ESTAT√çSTICAS FINAIS:" << endl;
    cout << "Itera√ß√µes realizadas: " << estatisticas.iterations << endl;
    cout << "Total de compara√ß√µes: " << estatisticas.comparisons << endl;
    cout << "Total de trocas: " << estatisticas.swaps << endl;
    cout << "Array final: ";
    for (int i = 0; i < tamanho; i++) {
        cout << numeros[i] << " ";
    }
    cout << endl;
    cout << "========================================" << endl;
    
    return 0;
}
```

## Exerc√≠cio 3: Bubble Sort Bidirecional (Cocktail Sort)

Implemente uma varia√ß√£o do Bubble Sort que funciona nas duas dire√ß√µes.

### üí° Solu√ß√£o do Exerc√≠cio 3

[C√≥digo completo](resources/cockTailSort.cpp)

```CPP
#include <iostream>
using namespace std;

void cocktailSort(int arr[], int size) {
    cout << "Implementando Cocktail Sort (Bubble Sort Bidirecional):" << endl;
    
    bool hasSwapped = true;
    int start = 0;
    int end = size - 1;
    int iteration = 0;
    
    while (hasSwapped) {
        iteration++;
        hasSwapped = false;
        
        cout << "\n>>> ITERA√á√ÉO " << iteration << " - DIRE√á√ÉO ‚Üí" << endl;
        // Passada da esquerda para direita
        for (int i = start; i < end; i++) {
            cout << "Comparando " << arr[i] << " com " << arr[i + 1];
            if (arr[i] > arr[i + 1]) {
                swap(arr[i], arr[i + 1]);
                hasSwapped = true;
                cout << " -> Trocado!" << endl;
            } else {
                cout << " -> Sem troca" << endl;
            }
        }
        
        if (!hasSwapped) {
            break;
        }
        
        end--;
        
        cout << "\n>>> ITERA√á√ÉO " << iteration << " - DIRE√á√ÉO ‚Üê" << endl;
        // Passada da direita para esquerda
        for (int i = end; i > start; i--) {
            cout << "Comparando " << arr[i] << " com " << arr[i - 1];
            if (arr[i] < arr[i - 1]) {
                swap(arr[i], arr[i - 1]);
                hasSwapped = true;
                cout << " -> Trocado!" << endl;
            } else {
                cout << " -> Sem troca" << endl;
            }
        }
        
        start++;
        
        cout << "Array ap√≥s itera√ß√£o " << iteration << ": ";
        for (int j = 0; j < size; j++) {
            cout << arr[j] << " ";
        }
        cout << endl;
    }
}

int main() {
    int numeros[] = {5, 1, 4, 2, 8, 0, 2};
    int tamanho = sizeof(numeros) / sizeof(numeros[0]);
    
    cout << "Array inicial: ";
    for (int i = 0; i < tamanho; i++) {
        cout << numeros[i] << " ";
    }
    cout << endl;
    
    cocktailSort(numeros, tamanho);
    
    cout << "\nArray final ordenado: ";
    for (int i = 0; i < tamanho; i++) {
        cout << numeros[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

## Exerc√≠cio 4: An√°lise de Performance

Compare o desempenho do Bubble Sort com e sem otimiza√ß√£o de parada antecipada.

### ü§î Desafio Extra

Implemente uma vers√£o do Bubble Sort que:

1. Conta opera√ß√µes (compara√ß√µes e trocas)

2. Para automaticamente quando detecta que est√° ordenado

3. Mostra estat√≠sticas detalhadas no final

4. Funciona com diferentes tipos de dados (int, float, string)

### üèÜ Solu√ß√£o do Desafio Extra

[C√≥digo completo](resources/advancedBubbleSort.cpp)

```CPP
#include <iostream>
#include <string>
#include <vector>
#include <chrono>
#include <iomanip>
using namespace std;
using namespace std::chrono;

// Estrutura para armazenar estat√≠sticas de ordena√ß√£o
struct SortingStats {
    int comparisons = 0;
    int swaps = 0;
    int iterations = 0;
    double timeElapsed = 0.0;
    bool optimizedExit = false;
};

// Template para Bubble Sort gen√©rico com estat√≠sticas
template<typename T>
void advancedBubbleSort(T arr[], int size, SortingStats& stats) {
    auto start = high_resolution_clock::now();
    
    cout << "\n========================================" << endl;
    cout << "ADVANCED BUBBLE SORT WITH STATISTICS" << endl;
    cout << "========================================" << endl;
    
    stats = {0, 0, 0, 0.0, false}; // Reset statistics
    
    cout << "Array inicial: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
    
    bool hasSwapped = true;
    
    while (hasSwapped && stats.iterations < size - 1) {
        hasSwapped = false;
        stats.iterations++;
        
        cout << ">>> ITERA√á√ÉO " << stats.iterations << " <<<" << endl;
        
        for (int i = 0; i < size - stats.iterations; i++) {
            stats.comparisons++;
            
            cout << "Compara√ß√£o " << stats.comparisons << ": " 
                 << arr[i] << " vs " << arr[i + 1];
            
            if (arr[i] > arr[i + 1]) {
                // Realizar troca
                T temp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = temp;
                
                stats.swaps++;
                hasSwapped = true;
                cout << " -> Troca " << stats.swaps << " realizada!" << endl;
            } else {
                cout << " -> Sem troca necess√°ria" << endl;
            }
        }
        
        cout << "Estado do array: ";
        for (int i = 0; i < size; i++) {
            if (i >= size - stats.iterations) {
                cout << "[" << arr[i] << "] ";
            } else {
                cout << arr[i] << " ";
            }
        }
        cout << endl;
        
        if (!hasSwapped) {
            stats.optimizedExit = true;
            cout << "üéØ OTIMIZA√á√ÉO: Array j√° ordenado! Parando antecipadamente." << endl;
        }
        cout << "--------------------------------" << endl;
    }
    
    auto end = high_resolution_clock::now();
    auto duration = duration_cast<microseconds>(end - start);
    stats.timeElapsed = duration.count() / 1000.0; // Convert to milliseconds
    
    cout << "\n========================================" << endl;
    cout << "ESTAT√çSTICAS DETALHADAS" << endl;
    cout << "========================================" << endl;
    cout << "Elementos no array: " << size << endl;
    cout << "Itera√ß√µes realizadas: " << stats.iterations << endl;
    cout << "Total de compara√ß√µes: " << stats.comparisons << endl;
    cout << "Total de trocas: " << stats.swaps << endl;
    cout << "Tempo de execu√ß√£o: " << fixed << setprecision(3) 
         << stats.timeElapsed << " ms" << endl;
    cout << "Otimiza√ß√£o ativada: " << (stats.optimizedExit ? "‚úÖ Sim" : "‚ùå N√£o") << endl;
    cout << "Efici√™ncia: " << fixed << setprecision(2) 
         << ((double)stats.swaps / stats.comparisons * 100) << "% das compara√ß√µes resultaram em trocas" << endl;
    
    cout << "\nArray final ordenado: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
    cout << "========================================" << endl;
}

// Fun√ß√£o para testar com diferentes tipos de dados
void testWithIntegers() {
    cout << "\nüî¢ TESTE COM N√öMEROS INTEIROS" << endl;
    int numeros[] = {64, 34, 25, 12, 22, 11, 90};
    int tamanho = sizeof(numeros) / sizeof(numeros[0]);
    SortingStats stats;
    
    advancedBubbleSort(numeros, tamanho, stats);
}

void testWithFloats() {
    cout << "\nüî¢ TESTE COM N√öMEROS DECIMAIS" << endl;
    float decimais[] = {3.14f, 2.71f, 1.41f, 1.73f, 0.57f};
    int tamanho = sizeof(decimais) / sizeof(decimais[0]);
    SortingStats stats;
    
    advancedBubbleSort(decimais, tamanho, stats);
}

void testWithStrings() {
    cout << "\nüìù TESTE COM STRINGS" << endl;
    string nomes[] = {"Maria", "Jo√£o", "Ana", "Pedro", "Carlos"};
    int tamanho = sizeof(nomes) / sizeof(nomes[0]);
    SortingStats stats;
    
    advancedBubbleSort(nomes, tamanho, stats);
}

void testWithAlreadySorted() {
    cout << "\n‚úÖ TESTE COM ARRAY J√Å ORDENADO (Demonstra√ß√£o de Otimiza√ß√£o)" << endl;
    int ordenado[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
    int tamanho = sizeof(ordenado) / sizeof(ordenado[0]);
    SortingStats stats;
    
    advancedBubbleSort(ordenado, tamanho, stats);
}

void testWithReverseSorted() {
    cout << "\n‚ùå TESTE COM ARRAY INVERSAMENTE ORDENADO (Pior Caso)" << endl;
    int reverso[] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
    int tamanho = sizeof(reverso) / sizeof(reverso[0]);
    SortingStats stats;
    
    advancedBubbleSort(reverso, tamanho, stats);
}

// Fun√ß√£o para comparar performance
void performanceComparison() {
    cout << "\nüìä COMPARA√á√ÉO DE PERFORMANCE" << endl;
    cout << "=============================" << endl;
    
    // Teste com diferentes tamanhos
    vector<int> sizes = {5, 10, 15};
    
    for (int size : sizes) {
        cout << "\nüîç Testando com " << size << " elementos:" << endl;
        
        // Criar array aleat√≥rio
        int* arr = new int[size];
        for (int i = 0; i < size; i++) {
            arr[i] = rand() % 100;
        }
        
        SortingStats stats;
        advancedBubbleSort(arr, size, stats);
        
        cout << "Resultado: " << stats.iterations << " itera√ß√µes, " 
             << stats.comparisons << " compara√ß√µes, " 
             << stats.swaps << " trocas em " 
             << stats.timeElapsed << " ms" << endl;
        
        delete[] arr;
    }
}

int main() {
    cout << "==================================================" << endl;
    cout << "BUBBLE SORT AVAN√áADO - DESAFIO EXTRA COMPLETO" << endl;
    cout << "==================================================" << endl;
    
    // Teste com diferentes tipos de dados
    testWithIntegers();
    testWithFloats();
    testWithStrings();
    
    // Testes especiais para demonstrar otimiza√ß√µes
    testWithAlreadySorted();
    testWithReverseSorted();
    
    // Compara√ß√£o de performance
    performanceComparison();
    
    cout << "\nüéâ Todos os testes foram conclu√≠dos com sucesso!" << endl;
    cout << "üìö Este exemplo demonstra:" << endl;
    cout << "   ‚úÖ Contagem de opera√ß√µes" << endl;
    cout << "   ‚úÖ Parada antecipada (otimiza√ß√£o)" << endl;
    cout << "   ‚úÖ Estat√≠sticas detalhadas" << endl;
    cout << "   ‚úÖ Suporte a diferentes tipos de dados" << endl;
    cout << "   ‚úÖ Medi√ß√£o de tempo de execu√ß√£o" << endl;
    cout << "   ‚úÖ An√°lise de efici√™ncia" << endl;
    
    return 0;
}
```

#### üîç Explica√ß√£o da Solu√ß√£o

Esta solu√ß√£o avan√ßada implementa todos os requisitos do desafio:

##### 

1. Contagem de Opera√ß√µes

* Struct `SortingStats` armazena compara√ß√µes, trocas, itera√ß√µes e tempo

* Cada opera√ß√£o √© contada e exibida em tempo real

##### 

2. Parada Antecipada

* Flag `hasSwapped` detecta quando n√£o h√° mais trocas

* Para automaticamente, economizando itera√ß√µes desnecess√°rias

##### 

3. Estat√≠sticas Detalhadas

* N√∫mero total de opera√ß√µes realizadas

* Tempo de execu√ß√£o em milissegundos

* Percentual de efici√™ncia (trocas/compara√ß√µes)

* Indica√ß√£o se a otimiza√ß√£o foi ativada

##### 

4. Suporte a Diferentes Tipos

* Template gen√©rico funciona com `int`, `float`, `string`

* Testes demonstram funcionamento com cada tipo

##### 

5. Recursos Extras

* Visualiza√ß√£o do processo de ordena√ß√£o

* Testes com casos especiais (j√° ordenado, inverso)

* Compara√ß√£o de performance com diferentes tamanhos

* Medi√ß√£o precisa de tempo de execu√ß√£o

Esta implementa√ß√£o √© ideal para estudos avan√ßados de algoritmos e an√°lise de performance!



# Conclus√£o

O Bubble Sort √© um algoritmo fundamental para aprender os conceitos de ordena√ß√£o devido √† sua simplicidade conceitual e facilidade de implementa√ß√£o. Embora n√£o seja eficiente para arrays grandes, √© excelente para fins educacionais e situa√ß√µes espec√≠ficas onde a estabilidade √© crucial.

O algoritmo demonstra claramente os conceitos de:

* Compara√ß√£o de elementos adjacentes

* Algoritmos est√°veis vs. inst√°veis

* Otimiza√ß√µes algor√≠tmicas (parada antecipada)

* An√°lise de complexidade no melhor e pior caso

* Trade-offs entre simplicidade e efici√™ncia

Quando usar Bubble Sort:

* Arrays muito pequenos (< 10 elementos)

* Situa√ß√µes educacionais

* Quando a estabilidade √© essencial

* Como base para entender algoritmos mais complexos



