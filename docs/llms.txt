# Learn Sorting Algorithm

## Entendendo Algoritmos de OrdenaÃ§Ã£o

Algoritmos de ordenaÃ§Ã£o funcionam como organizar uma bagunÃ§a - vocÃª pega uma lista desordenada (como anÃµes de tamanhos diferentes) e os coloca na ordem correta (do menor para o maior ou vice-versa).

Imagine esta fila de anÃµes:

![Fila de anÃ£o](images/filadeanao.png)

## Conceitos Fundamentais Antes de ComeÃ§ar

Antes de mergulharmos no algoritmo, vamos entender alguns conceitos bÃ¡sicos:

### O que Ã© um Algoritmo?

Um algoritmo Ã© simplesmente uma lista de instruÃ§Ãµes passo a passo para resolver um problema. Ã‰ como uma receita de bolo - vocÃª segue os passos na ordem certa para chegar ao resultado desejado.

Tip:

Exemplo prÃ¡tico: Para fazer um sanduÃ­che, o algoritmo seria:

1. Pegue duas fatias de pÃ£o

2. Passe manteiga em uma fatia

3. Coloque o recheio

4. Feche com a outra fatia

### O que Ã© IteraÃ§Ã£o?

IteraÃ§Ã£o Ã© quando repetimos um conjunto de passos vÃ¡rias vezes. Ã‰ como quando vocÃª escova os dentes - faz o mesmo movimento vÃ¡rias vezes atÃ© limpar todos os dentes.

Em programaÃ§Ã£o, quando dizemos:

* "IteraÃ§Ã£o 1" = primeira vez que executamos os passos

* "IteraÃ§Ã£o 2" = segunda vez que executamos os passos

* E assim por diante...

### O que Ã© ComparaÃ§Ã£o?

Comparar Ã© verificar qual elemento Ã© maior, menor ou igual ao outro. Ã‰ como quando vocÃª compara a altura de duas pessoas para saber quem Ã© mais alto.

## O BÃ¡sico do Algoritmo de OrdenaÃ§Ã£o

Nosso algoritmo simples compara os elementos um a um, como quando vocÃª organiza suas roupas - pega cada peÃ§a e compara com as outras para ver qual Ã© maior ou menor.

## Como Funciona na PrÃ¡tica

Agora vamos ver como o algoritmo trabalha iteraÃ§Ã£o por iteraÃ§Ã£o (ou seja, repetiÃ§Ã£o por repetiÃ§Ã£o):

### Primeira IteraÃ§Ã£o (1Âª RepetiÃ§Ã£o)

Comparo o primeiro anÃ£o ($i_1$) com o segundo anÃ£o ($j_1$).

* Pergunta: O primeiro Ã© menor que o segundo?

* Resposta: Sim (verdadeiro) â†’ NÃ£o preciso trocar nada!

![Primeira iteraÃ§Ã£o](images/Primeiraiteracao.png)

### Segunda IteraÃ§Ã£o (2Âª RepetiÃ§Ã£o)

Agora comparo $i_2$ com $j_2$.

* Pergunta: O primeiro Ã© menor que o segundo?

* Resposta: NÃ£o (falso) â†’ Preciso trocar eles de lugar!

![Segunda iteraÃ§Ã£o](images/segundaint.png)

### Terceira IteraÃ§Ã£o (3Âª RepetiÃ§Ã£o)

Comparo $i_{3}$ com $j_{3}$.

* Pergunta: O primeiro Ã© menor que o segundo?

* Resposta: Sim (verdadeiro) â†’ NÃ£o preciso trocar nada!

![Terceira iteraÃ§Ã£o](images/terceiraint.png)

### Quarta IteraÃ§Ã£o (4Âª RepetiÃ§Ã£o)

Comparo $i_{4}$ com $j_{4}$.

* Pergunta: O primeiro Ã© menor que o segundo?

* Resposta: NÃ£o (falso) â†’ Preciso trocar eles de lugar!

![Quarta iteraÃ§Ã£o](images/quartaiteracao.png)

### Quinta IteraÃ§Ã£o (5Âª e Ãšltima RepetiÃ§Ã£o)

Agora todos os elementos jÃ¡ estÃ£o na ordem correta!

![Quinta interaÃ§Ã£o](images/quintainteracao.png)
Tip:

Resumo: A cada iteraÃ§Ã£o, fazemos uma pergunta (comparaÃ§Ã£o) e tomamos uma decisÃ£o (trocar ou nÃ£o trocar). Repetimos isso atÃ© que tudo esteja organizado!

## O Que Todo Algoritmo de OrdenaÃ§Ã£o Precisa

Resumindo, todo algoritmo de ordenaÃ§Ã£o possui:

1. Entrada: A lista desordenada

2. Tipo de ordem: Crescente ou decrescente

3. IteraÃ§Ãµes: Quantidade de repetiÃ§Ãµes do processo

4. ComparaÃ§Ãµes: CritÃ©rio para comparar os elementos

5. SaÃ­da: A lista organizada

```MERMAID
graph TD
    A[Algoritmo] --> B[Lista desordenada]
    A --> C[Ordem crescente/decrescente]
    A --> D[RepetiÃ§Ãµes necessÃ¡rias]
    A --> E[Como comparar]
    A --> F[Lista ordenada]
```

## Partindo para o CÃ³digo

Agora vamos ver como transformar nossa lÃ³gica em cÃ³digo C++. Vou explicar cada parte:

### Conceitos BÃ¡sicos Antes do CÃ³digo

#### O que Ã© um Array?

Um array Ã© como uma fileira de caixas numeradas onde guardamos valores. Cada caixa tem um nÃºmero (Ã­ndice) e pode guardar um valor.

```
Array: [5] [2] [8] [1] [9]
Ãndice: 0   1   2   3   4
```

#### O que Ã© um Loop For?

Um loop for Ã© uma forma de repetir uma aÃ§Ã£o vÃ¡rias vezes. Ã‰ como dizer: "faÃ§a isso 10 vezes" ou "faÃ§a isso para cada elemento da lista".

```CPLUSPLUS
for (int i = 0; i < 5; i++) {
    // Este cÃ³digo vai executar 5 vezes
    // i vai valer: 0, 1, 2, 3, 4
}
```

### O CÃ³digo Completo Explicado

```CPLUSPLUS
#include <iostream>  // Para usar cout e cin (entrada e saÃ­da)
#include <cstdlib>   // Para usar rand() (nÃºmeros aleatÃ³rios)
#define MAX_SIZE 100 // Define o tamanho mÃ¡ximo do array
using namespace std;

int main()
{
    // PARTE 1: DECLARAÃ‡ÃƒO DAS VARIÃVEIS
    int n;                // Quantos nÃºmeros vamos ordenar
    int array[MAX_SIZE];  // Nossa lista de nÃºmeros (o array)

    // PARTE 2: ENTRADA DE DADOS
    cout << "Digite quantos nÃºmeros vocÃª quer ordenar: " << endl;
    cin >> n;  // LÃª a resposta do usuÃ¡rio

    // PARTE 3: PREENCHIMENTO COM NÃšMEROS ALEATÃ“RIOS
    cout << "Gerando " << n << " nÃºmeros aleatÃ³rios..." << endl;
    for (int i = 0; i < n; i++) {
        array[i] = rand() % 100;  // Gera nÃºmero entre 0 e 99
    }

    // PARTE 4: MOSTRA A LISTA BAGUNÃ‡ADA
    cout << "\nLista original (bagunÃ§ada): ";
    for (int i = 0; i < n; i++) {
        cout << "[" << array[i] << "] ";
    }
    cout << endl << endl;

    // PARTE 5: O ALGORITMO DE ORDENAÃ‡ÃƒO (O CORAÃ‡ÃƒO DO PROGRAMA!)
    cout << "Iniciando ordenaÃ§Ã£o..." << endl;
    
    // Loop externo: seleciona cada elemento (iteraÃ§Ã£o principal)
    for (int i = 0; i < n; i++) {
        
        // Loop interno: compara com os elementos seguintes
        for (int j = i + 1; j < n; j++) {
            
            // Mostra o que estÃ¡ sendo comparado
            cout << "Comparando: " << array[i] << " com " << array[j];
            
            // AQUI Ã‰ ONDE A MÃGICA ACONTECE!
            // Se o primeiro for MENOR que o segundo, trocamos
            if (array[i] < array[j]) {
                cout << " â†’ Trocando!" << endl;
                
                // PROCESSO DE TROCA (como trocar duas cartas de lugar)
                int temp = array[i];  // Guarda o primeiro valor
                array[i] = array[j];  // PÃµe o segundo no lugar do primeiro
                array[j] = temp;      // PÃµe o primeiro no lugar do segundo
            } else {
                cout << " â†’ NÃ£o precisa trocar" << endl;
            }
        }
    }

    // PARTE 6: MOSTRA O RESULTADO FINAL
    cout << "\n" << "=" << endl;
    cout << "Lista ordenada (maior para menor): ";
    for (int i = 0; i < n; i++) {
        cout << "[" << array[i] << "] ";
    }
    cout << endl;

    return 0;  // Programa terminou com sucesso
}
```

### Pontos Importantes Para Entender:

#### 

1. Como Funciona o rand()

* `rand()` gera nÃºmeros aleatÃ³rios gigantes

* `rand() % 100` limita os nÃºmeros entre 0 e 99 (mais fÃ¡cil de trabalhar)

#### 

2. Por que Dois Loops For?

* Loop externo (i): Escolhe cada elemento da lista, um por vez

* Loop interno (j): Compara esse elemento com todos os outros que vÃªm depois

* Ã‰ como comparar cada anÃ£o com todos os outros anÃµes

#### 

3. Como Funciona a Troca (Swap)?

Imagine que vocÃª tem duas cartas e quer trocar elas de lugar:

```CPLUSPLUS
int temp = array[i];  // Guardo a primeira carta na mÃ£o
array[i] = array[j];  // Ponho a segunda carta no lugar da primeira
array[j] = temp;      // Ponho a primeira carta (que estava na mÃ£o) no lugar da segunda
```

#### 

4. Mudando a Ordem

* Para ordem DECRESCENTE (maior â†’ menor): use `if (array[i] < array[j])`

* Para ordem CRESCENTE (menor â†’ maior): use `if (array[i] > array[j])`

### Importante Saber

Este algoritmo se chama Selection Sort (OrdenaÃ§Ã£o por SeleÃ§Ã£o). Ele nÃ£o Ã© o mais rÃ¡pido para listas muito grandes, mas Ã© perfeito para aprender porque:

* âœ… Ã‰ fÃ¡cil de entender

* âœ… Mostra claramente como funciona a ordenaÃ§Ã£o

* âœ… Usa conceitos bÃ¡sicos que vocÃª vai usar sempre

Tip:

Dica: Execute o cÃ³digo algumas vezes com nÃºmeros pequenos (como 5 elementos) para ver exatamente como ele funciona!



# Selection Sort

## O que Ã© Selection Sort?

O Selection Sort Ã© um algoritmo de ordenaÃ§Ã£o simples e intuitivo que funciona dividindo o array em duas partes:

* Parte ordenada: Localizada no inÃ­cio do array (inicialmente vazia)

* Parte nÃ£o ordenada: Localizada no final do array (inicialmente todo o array)

## Como funciona?

O algoritmo funciona da seguinte forma:

1. Encontra o menor elemento da parte nÃ£o ordenada

2. Troca esse elemento com o primeiro elemento da parte nÃ£o ordenada

3. Expande a parte ordenada em uma posiÃ§Ã£o

4. Repete o processo atÃ© que todo o array esteja ordenado

## DiagramaÃ§Ã£o

![selectionSort_annotated.png](images/selectionSort_annotated.png)

## Exemplo Visual

Considerando o array: `[64, 25, 12, 22, 11]`

IteraÃ§Ã£o 1:

* Parte ordenada: `[]`

* Parte nÃ£o ordenada: `[64, 25, 12, 22, 11]`

* Menor elemento: `11` (posiÃ§Ã£o 4)

* Troca: `11` â†” `64`

* Resultado: `[11, 25, 12, 22, 64]`

IteraÃ§Ã£o 2:

* Parte ordenada: `[11]`

* Parte nÃ£o ordenada: `[25, 12, 22, 64]`

* Menor elemento: `12` (posiÃ§Ã£o 2)

* Troca: `12` â†” `25`

* Resultado: `[11, 12, 25, 22, 64]`

IteraÃ§Ã£o 3:

* Parte ordenada: `[11, 12]`

* Parte nÃ£o ordenada: `[25, 22, 64]`

* Menor elemento: `22` (posiÃ§Ã£o 3)

* Troca: `22` â†” `25`

* Resultado: `[11, 12, 22, 25, 64]`

IteraÃ§Ã£o 4:

* Parte ordenada: `[11, 12, 22]`

* Parte nÃ£o ordenada: `[25, 64]`

* Menor elemento: `25` (jÃ¡ na posiÃ§Ã£o correta)

* Sem troca necessÃ¡ria

* Resultado: `[11, 12, 22, 25, 64]`



# ImplementaÃ§Ã£o

Nossa implementaÃ§Ã£o educativa inclui saÃ­das detalhadas para ajudar no aprendizado.

VocÃª pode encontrar uma implementaÃ§Ã£o completa e educativa do Selection Sort em:

[* ğŸ“ `Domus/Domus-1/selectionSort.cpp`](resources/selectionSort.cpp)

## FunÃ§Ã£o Principal - Selection Sort Algorithm

```CPP
void selectionSortAlgorithm(int dataArray[], int arraySize)
{
    cout << "========================================" << endl;
    cout << "STARTING SELECTION SORT ALGORITHM" << endl;
    cout << "========================================" << endl;
    cout << "Initial array: ";
    for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
        cout << dataArray[displayIndex] << " ";
    }
    cout << endl << endl;

    int totalNumberOfSwaps = 0;

    for (int currentPosition = 0; currentPosition < arraySize - 1; currentPosition++)
    {
        cout << ">>> ITERATION " << (currentPosition + 1) << " <<<" << endl;
        cout << "Looking for smallest element for position " << currentPosition << endl;
        
        int smallestElementIndex = findSmallestElementIndex(dataArray, currentPosition, arraySize - 1);

        if (currentPosition != smallestElementIndex) {
            cout << "Smallest element is at position " << smallestElementIndex << ", need to swap with position " << currentPosition << endl;
            swapElements(dataArray, currentPosition, smallestElementIndex);
            totalNumberOfSwaps++;
        } else {
            cout << "Smallest element is already in correct position (" << currentPosition << "), no swap needed" << endl;
        }

        cout << "Array state after iteration " << (currentPosition + 1) << ": ";
        for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
            if (displayIndex <= currentPosition) {
                cout << "[" << dataArray[displayIndex] << "] "; // Already sorted elements
            } else {
                cout << dataArray[displayIndex] << " ";        // Not yet sorted elements
            }
        }
        cout << endl;
        cout << "Elements sorted: " << (currentPosition + 1) << "/" << arraySize << endl;
        cout << "--------------------------------" << endl;
    }

    cout << "========================================" << endl;
    cout << "SELECTION SORT ALGORITHM COMPLETED!" << endl;
    cout << "Total number of swaps performed: " << totalNumberOfSwaps << endl;
    cout << "========================================" << endl;
}
```

## FunÃ§Ã£o para Encontrar o Menor Elemento

```CPP
int findSmallestElementIndex(int dataArray[], int startIndex, int endIndex)
{
    cout << "--- Searching for smallest element in range [" << startIndex << ", " << endIndex << "] ---" << endl;
    int currentIndex = startIndex;
    int smallestIndex = currentIndex;
    int numberOfComparisons = 0;

    cout << "Initial element for comparison: dataArray[" << smallestIndex << "] = " << dataArray[smallestIndex] << endl;

    while (currentIndex <= endIndex)
    {
        cout << "Comparing dataArray[" << currentIndex << "] = " << dataArray[currentIndex] << " with current smallest dataArray[" << smallestIndex << "] = " << dataArray[smallestIndex];
        numberOfComparisons++;
        
        if (dataArray[currentIndex] < dataArray[smallestIndex])
        {
            cout << " -> " << dataArray[currentIndex] << " is smaller! New smallest element found at position " << currentIndex << endl;
            smallestIndex = currentIndex;
        }
        else
        {
            cout << " -> " << dataArray[currentIndex] << " >= " << dataArray[smallestIndex] << ", keeping current smallest" << endl;
        }

        currentIndex++;
    }

    cout << "Smallest element found: " << dataArray[smallestIndex] << " at position " << smallestIndex << " (after " << numberOfComparisons << " comparisons)" << endl;
    return smallestIndex;
}
```

## FunÃ§Ã£o para Trocar Elementos

```CPP
void swapElements(int dataArray[], int firstPosition, int secondPosition)
{
    cout << "  -> Swapping elements: " << dataArray[firstPosition] << " (position " << firstPosition << ") <-> " << dataArray[secondPosition] << " (position " << secondPosition << ")" << endl;
    int temporaryValue = dataArray[firstPosition];
    dataArray[firstPosition] = dataArray[secondPosition];
    dataArray[secondPosition] = temporaryValue;
    cout << "  -> After swap: position " << firstPosition << " = " << dataArray[firstPosition] << ", position " << secondPosition << " = " << dataArray[secondPosition] << endl;
}
```

## CaracterÃ­sticas do Algoritmo

### Complexidade de Tempo

* Melhor caso: O(nÂ²) - Mesmo que o array jÃ¡ esteja ordenado

* Caso mÃ©dio: O(nÂ²) - Comportamento tÃ­pico

* Pior caso: O(nÂ²) - Array ordenado inversamente

### Complexidade de EspaÃ§o

* O(1) - Algoritmo in-place, usa apenas memÃ³ria constante adicional

### Propriedades Importantes

| Propriedade |Valor |
----------------------
| EstÃ¡vel |âŒ NÃ£o |
| In-place |âœ… Sim |
| Adaptivo |âŒ NÃ£o |
| ComparaÃ§Ãµes |O(nÂ²) |
| Trocas |O(n) |



# Por que o Selection Sort NÃƒO Ã© EstÃ¡vel?

## O que significa "Estabilidade" em algoritmos de ordenaÃ§Ã£o?

Um algoritmo de ordenaÃ§Ã£o Ã© estÃ¡vel quando mantÃ©m a ordem relativa dos elementos que possuem valores iguais. Ou seja, se dois elementos tÃªm o mesmo valor, aquele que aparece primeiro no array original deve aparecer primeiro no array ordenado.

## Exemplo PrÃ¡tico de Instabilidade

Considere um array de cartas onde cada carta tem um valor e um naipe:

Array inicial: `[5â™ , 3â™¦, 5â™¥, 2â™£, 3â™ ]`

Vamos ordenar por valor numÃ©rico apenas, ignorando o naipe:

### âœ… OrdenaÃ§Ã£o EstÃ¡vel (esperada):

`[2â™£, 3â™¦, 3â™ , 5â™ , 5â™¥]`

* Note que `3â™¦` vem antes de `3â™ ` (mantÃ©m ordem original)

* E `5â™ ` vem antes de `5â™¥` (mantÃ©m ordem original)

### âŒ Selection Sort (instÃ¡vel):

`[2â™£, 3â™ , 3â™¦, 5â™¥, 5â™ ]`

* `3â™ ` agora vem antes de `3â™¦` (ordem alterada!)

* `5â™¥` agora vem antes de `5â™ ` (ordem alterada!)

## Por que isso acontece no Selection Sort?

O Selection Sort troca elementos distantes entre si, o que pode "pular" sobre elementos iguais e alterar sua ordem relativa.

### DemonstraÃ§Ã£o com nÃºmeros simples:

Array inicial: `[4, 2, 4, 1, 3]`

* Para distinguir, vamos chamar: `[4a, 2, 4b, 1, 3]`

ExecuÃ§Ã£o do Selection Sort:

IteraÃ§Ã£o 1:

* Procura menor elemento: `1` (posiÃ§Ã£o 3)

* Troca: `4a` â†” `1`

* Resultado: `[1, 2, 4b, 4a, 3]`

Warning:

Observe: `4b` agora vem antes de `4a`!

IteraÃ§Ã£o 2:

* Procura menor na parte nÃ£o ordenada `[2, 4b, 4a, 3]`: `2` jÃ¡ estÃ¡ correto

* Sem troca

* Resultado: `[1, 2, 4b, 4a, 3]`

IteraÃ§Ã£o 3:

* Procura menor na parte nÃ£o ordenada `[4b, 4a, 3]`: `3` (posiÃ§Ã£o 4)

* Troca: `4b` â†” `3`

* Resultado: `[1, 2, 3, 4a, 4b]`

Array final: `[1, 2, 3, 4a, 4b]`

## O Problema da "Troca Distante"

```
Array: [4a, 2, 4b, 1, 3]
        â†‘           â†‘
        |___________|
     Troca distante que "pula"
     sobre 4b, alterando a ordem!
```

Quando o Selection Sort encontra o menor elemento em uma posiÃ§Ã£o distante, ele o troca diretamente com a posiÃ§Ã£o atual, pulando sobre todos os elementos intermediÃ¡rios, incluindo aqueles que tÃªm o mesmo valor.

## Impacto PrÃ¡tico da Instabilidade

A instabilidade pode ser problemÃ¡tica em situaÃ§Ãµes reais:

1. OrdenaÃ§Ã£o de registros de funcionÃ¡rios por salÃ¡rio:

* Se dois funcionÃ¡rios tÃªm o mesmo salÃ¡rio, vocÃª pode querer manter a ordem original (ex: por data de contrataÃ§Ã£o)

2. ClassificaÃ§Ã£o de produtos por preÃ§o:

* Produtos com mesmo preÃ§o podem ter diferentes prioridades de exibiÃ§Ã£o

3. OrdenaÃ§Ã£o de notas de alunos:

* Alunos com a mesma nota podem estar em ordem alfabÃ©tica inicialmente

## Como tornar o Selection Sort estÃ¡vel?

Ã‰ possÃ­vel modificar o Selection Sort para ser estÃ¡vel, mas isso aumenta a complexidade:

```CPP
// VersÃ£o estÃ¡vel (menos eficiente)
void stableSelectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int minIdx = i;
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // Em vez de trocar diretamente, 
        // desloca todos os elementos entre i e minIdx
        int key = arr[minIdx];
        while (minIdx > i) {
            arr[minIdx] = arr[minIdx-1];
            minIdx--;
        }
        arr[i] = key;
    }
}
```

Warning:

Mas isso aumenta a complexidade de trocas de O(n) para O(nÂ²)!

## VisualizaÃ§Ã£o da Instabilidade - "Rotatividade"

O conceito de "rotatividade" que vocÃª mencionou refere-se Ã  forma como os elementos "giram" ou alteram suas posiÃ§Ãµes relativas durante as trocas distantes:

```
Estado inicial: [4a, 2, 4b, 1, 3]
                 â–²              â–²
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ Troca distante na iteraÃ§Ã£o 1

ApÃ³s troca:     [1, 2, 4b, 4a, 3]
                        â–²   â–²
                     4b "rotacionou" para frente de 4a

Estado inicial: [A, B, C, D] (onde A = D em valor)
ApÃ³s Selection: [D, B, C, A] (A e D trocaram posiÃ§Ãµes!)
                 â–²        â–²
                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ "Rotatividade" - ordem relativa invertida
```

## ComparaÃ§Ã£o Visual: EstÃ¡vel vs InstÃ¡vel

### Algoritmo EstÃ¡vel (ex: Insertion Sort):

```
[3a, 1, 3b, 2] â†’ [1, 2, 3a, 3b] âœ… Ordem mantida
 â–²      â–²                â–²   â–²
 â””â”€â”€â”€â”€â”€â”€â”˜                â””â”€â”€â”€â”˜ 3a ainda vem antes de 3b
```

### Selection Sort (InstÃ¡vel):

```
[3a, 1, 3b, 2] â†’ [1, 2, 3b, 3a] âŒ Ordem alterada!
 â–²      â–²               â–²   â–²
 â””â”€â”€â”€â”€â”€â”€â”˜               â””â”€â”€â”€â”˜ 3b agora vem antes de 3a
```

## Resumo: Por que Selection Sort Ã© InstÃ¡vel

* Trocas distantes: Elementos sÃ£o trocados atravÃ©s de grandes distÃ¢ncias

* Pula elementos: Ignora elementos iguais no meio do caminho

* Foco apenas no valor: NÃ£o considera a posiÃ§Ã£o original dos elementos iguais

* Prioriza eficiÃªncia: A versÃ£o estÃ¡vel seria muito menos eficiente

* Rotatividade: Elementos iguais podem "rotacionar" suas posiÃ§Ãµes relativas



# Vantagens vs. Disvantagens

## Vantagens

* âœ… Simples de implementar e entender

* âœ… Poucas trocas: MÃ¡ximo de n-1 trocas

* âœ… In-place: NÃ£o requer memÃ³ria adicional

* âœ… Funciona bem com arrays pequenos

* âœ… Eficiente quando operaÃ§Ãµes de escrita sÃ£o caras

## Desvantagens

* âŒ Complexidade O(nÂ²): Ineficiente para arrays grandes

* âŒ NÃ£o Ã© estÃ¡vel: Pode alterar a ordem relativa de elementos iguais

* âŒ NÃ£o Ã© adaptivo: NÃ£o aproveita arrays parcialmente ordenados

* âŒ Sempre faz n-1 passadas: Mesmo que o array jÃ¡ esteja ordenado



# Quando Usar?

O Selection Sort Ã© adequado quando:

* Arrays pequenos (< 50 elementos)

* OperaÃ§Ãµes de escrita sÃ£o caras (ex: memÃ³ria flash)

* Simplicidade Ã© mais importante que eficiÃªncia

* MemÃ³ria Ã© limitada (algoritmo in-place)



# ComparaÃ§Ã£o com Outros Algoritmos

| Algoritmo |Melhor Caso |Caso MÃ©dio |Pior Caso |EstÃ¡vel |Trocas |
------------------------------------------------------------------
| Selection Sort |O(nÂ²) |O(nÂ²) |O(nÂ²) |âŒ |O(n) |
| Bubble Sort |O(n) |O(nÂ²) |O(nÂ²) |âœ… |O(nÂ²) |
| Insertion Sort |O(n) |O(nÂ²) |O(nÂ²) |âœ… |O(nÂ²) |
| Merge Sort |O(n log n) |O(n log n) |O(n log n) |âœ… |- |
| Quick Sort |O(n log n) |O(n log n) |O(nÂ²) |âŒ |O(n log n) |



# VariaÃ§Ãµes do Selection Sort

## 1. Selection Sort Bidirecional

Encontra simultaneamente o menor e maior elemento em cada passada, colocando-os nas extremidades.

## 2. Selection Sort Recursivo

ImplementaÃ§Ã£o recursiva que ordena recursivamente subarray apÃ³s colocar o menor elemento na primeira posiÃ§Ã£o.

## 3. Selection Sort EstÃ¡vel

ModificaÃ§Ã£o que mantÃ©m a estabilidade trocando elementos apenas quando necessÃ¡rio.



# ExercÃ­cios PrÃ¡ticos

## ExercÃ­cio 1: ImplementaÃ§Ã£o BÃ¡sica

Implemente o Selection Sort para ordenar um array de strings por ordem alfabÃ©tica.

### ğŸ’¡ SoluÃ§Ã£o do ExercÃ­cio 1

[CÃ³digo completo](resources/selectionSortString.cpp)

```CPP
#include <iostream>
#include <string>
using namespace std;

// FunÃ§Ã£o para encontrar o Ã­ndice da menor string
int findSmallestStringIndex(string arr[], int start, int end) {
    int smallestIndex = start;
    
    for (int i = start + 1; i <= end; i++) {
        if (arr[i] < arr[smallestIndex]) {
            smallestIndex = i;
        }
    }
    
    return smallestIndex;
}

// FunÃ§Ã£o para trocar duas strings
void swapStrings(string arr[], int pos1, int pos2) {
    string temp = arr[pos1];
    arr[pos1] = arr[pos2];
    arr[pos2] = temp;
}

// Selection Sort para strings
void selectionSortStrings(string arr[], int size) {
    cout << "Ordenando strings por ordem alfabÃ©tica:" << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "\nIteraÃ§Ã£o " << (i + 1) << ":" << endl;
        
        int smallestIndex = findSmallestStringIndex(arr, i, size - 1);
        
        if (i != smallestIndex) {
            cout << "Trocando \"" << arr[i] << "\" com \"" << arr[smallestIndex] << "\"" << endl;
            swapStrings(arr, i, smallestIndex);
        } else {
            cout << "\"" << arr[i] << "\" jÃ¡ estÃ¡ na posiÃ§Ã£o correta" << endl;
        }
        
        // Mostrar estado atual
        cout << "Array atual: ";
        for (int j = 0; j < size; j++) {
            if (j <= i) {
                cout << "[" << arr[j] << "] ";
            } else {
                cout << arr[j] << " ";
            }
        }
        cout << endl;
    }
}

// Exemplo de uso
int main() {
    string frutas[] = {"banana", "maÃ§Ã£", "laranja", "uva", "abacaxi"};
    int tamanho = 5;
    
    cout << "Array inicial: ";
    for (int i = 0; i < tamanho; i++) {
        cout << frutas[i] << " ";
    }
    cout << endl;
    
    selectionSortStrings(frutas, tamanho);
    
    cout << "\nArray final ordenado: ";
    for (int i = 0; i < tamanho; i++) {
        cout << frutas[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

Pontos importantes:

* Usamos o operador `<` para comparaÃ§Ã£o lexicogrÃ¡fica de strings

* A lÃ³gica Ã© a mesma do Selection Sort para nÃºmeros

* Strings sÃ£o ordenadas alfabeticamente (A-Z)

## ExercÃ­cio 2: Contagem de OperaÃ§Ãµes

Modifique o algoritmo para contar o nÃºmero de comparaÃ§Ãµes e trocas realizadas.

### ğŸ’¡ SoluÃ§Ã£o do ExercÃ­cio 2

[CÃ³digo completo](resources/selectionWithStats.cpp)

```CPP
#include <iostream>
using namespace std;

// Estrutura para armazenar estatÃ­sticas
struct SortStatistics {
    int comparisons;
    int swaps;
    
    SortStatistics() : comparisons(0), swaps(0) {}
};

// FunÃ§Ã£o para encontrar o menor elemento com contagem de comparaÃ§Ãµes
int findSmallestWithStats(int arr[], int start, int end, SortStatistics& stats) {
    int smallestIndex = start;
    
    for (int i = start + 1; i <= end; i++) {
        stats.comparisons++; // Incrementa contador de comparaÃ§Ãµes
        
        if (arr[i] < arr[smallestIndex]) {
            smallestIndex = i;
        }
    }
    
    return smallestIndex;
}

// FunÃ§Ã£o para trocar elementos com contagem
void swapWithStats(int arr[], int pos1, int pos2, SortStatistics& stats) {
    if (pos1 != pos2) {
        stats.swaps++; // Incrementa contador de trocas
        
        int temp = arr[pos1];
        arr[pos1] = arr[pos2];
        arr[pos2] = temp;
        
        cout << "  Troca #" << stats.swaps << ": " << arr[pos1] 
             << " <-> " << arr[pos2] << endl;
    }
}

// Selection Sort com estatÃ­sticas
void selectionSortWithStats(int arr[], int size) {
    SortStatistics stats;
    
    cout << "=== SELECTION SORT COM ESTATÃSTICAS ===" << endl;
    cout << "Array inicial: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "IteraÃ§Ã£o " << (i + 1) << ":" << endl;
        
        int smallestIndex = findSmallestWithStats(arr, i, size - 1, stats);
        
        cout << "  Menor elemento: " << arr[smallestIndex] 
             << " (posiÃ§Ã£o " << smallestIndex << ")" << endl;
        
        swapWithStats(arr, i, smallestIndex, stats);
        
        cout << "  ComparaÃ§Ãµes nesta iteraÃ§Ã£o: " 
             << (stats.comparisons - (i > 0 ? (size - i) : 0)) << endl;
        cout << "  Array atual: ";
        for (int j = 0; j < size; j++) {
            if (j <= i) {
                cout << "[" << arr[j] << "] ";
            } else {
                cout << arr[j] << " ";
            }
        }
        cout << endl << endl;
    }
    
    // Exibir estatÃ­sticas finais
    cout << "========== ESTATÃSTICAS FINAIS ==========" << endl;
    cout << "Total de comparaÃ§Ãµes: " << stats.comparisons << endl;
    cout << "Total de trocas: " << stats.swaps << endl;
    cout << "EficiÃªncia de trocas: " << stats.swaps << "/" << (size - 1) 
         << " (" << (stats.swaps * 100.0 / (size - 1)) << "%)" << endl;
    cout << "ComparaÃ§Ãµes teÃ³ricas O(nÂ²): " << (size * (size - 1) / 2) << endl;
    cout << "ComparaÃ§Ãµes reais vs teÃ³ricas: " << stats.comparisons 
         << "/" << (size * (size - 1) / 2) << endl;
}

// Exemplo de uso
int main() {
    int numeros[] = {64, 34, 25, 12, 22, 11, 90};
    int tamanho = 7;
    
    selectionSortWithStats(numeros, tamanho);
    
    return 0;
}
```

AnÃ¡lise das EstatÃ­sticas:

* ComparaÃ§Ãµes: Sempre n(n-1)/2 independente da entrada

* Trocas: No mÃ¡ximo n-1, pode ser menor se alguns elementos jÃ¡ estÃ£o no lugar

* EficiÃªncia: Mostra quantas trocas foram realmente necessÃ¡rias

## ExercÃ­cio 3: VersÃ£o EstÃ¡vel

Implemente uma versÃ£o estÃ¡vel do Selection Sort.

### ğŸ’¡ SoluÃ§Ã£o do ExercÃ­cio 3

[CÃ³digo completo](resources/stableSelection.cpp)

```CPP
#include <iostream>
using namespace std;

// FunÃ§Ã£o para rotacionar elementos para manter estabilidade
void rotateRight(int arr[], int start, int end) {
    int temp = arr[end];
    for (int i = end; i > start; i--) {
        arr[i] = arr[i - 1];
    }
    arr[start] = temp;
}

// Selection Sort EstÃ¡vel
void stableSelectionSort(int arr[], int size) {
    cout << "=== SELECTION SORT ESTÃVEL ===" << endl;
    cout << "Array inicial: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "IteraÃ§Ã£o " << (i + 1) << ":" << endl;
        
        // Encontrar o menor elemento na parte nÃ£o ordenada
        int minIndex = i;
        for (int j = i + 1; j < size; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        cout << "  Menor elemento: " << arr[minIndex] 
             << " (posiÃ§Ã£o " << minIndex << ")" << endl;
        
        // Em vez de trocar, rotacionar para manter estabilidade
        if (minIndex != i) {
            cout << "  Rotacionando elementos da posiÃ§Ã£o " << i 
                 << " atÃ© " << minIndex << endl;
            
            int minValue = arr[minIndex];
            rotateRight(arr, i, minIndex);
            
            cout << "  Elemento " << minValue 
                 << " movido para posiÃ§Ã£o " << i << " mantendo ordem relativa" << endl;
        } else {
            cout << "  Elemento jÃ¡ estÃ¡ na posiÃ§Ã£o correta" << endl;
        }
        
        cout << "  Array atual: ";
        for (int j = 0; j < size; j++) {
            if (j <= i) {
                cout << "[" << arr[j] << "] ";
            } else {
                cout << arr[j] << " ";
            }
        }
        cout << endl << endl;
    }
    
    cout << "Array final ordenado (estÃ¡vel): ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// VersÃ£o para demonstrar estabilidade com pares (valor, Ã­ndice original)
struct Element {
    int value;
    int originalIndex;
};

void printElements(Element arr[], int size, string label) {
    cout << label;
    for (int i = 0; i < size; i++) {
        cout << "(" << arr[i].value << "," << arr[i].originalIndex << ") ";
    }
    cout << endl;
}

void stableSelectionSortDemo(Element arr[], int size) {
    cout << "\n=== DEMONSTRAÃ‡ÃƒO DE ESTABILIDADE ===" << endl;
    printElements(arr, size, "Array inicial: ");
    
    for (int i = 0; i < size - 1; i++) {
        // Encontrar o menor elemento
        int minIndex = i;
        for (int j = i + 1; j < size; j++) {
            if (arr[j].value < arr[minIndex].value) {
                minIndex = j;
            }
        }
        
        // Rotacionar para manter ordem relativa
        if (minIndex != i) {
            Element minElement = arr[minIndex];
            for (int k = minIndex; k > i; k--) {
                arr[k] = arr[k - 1];
            }
            arr[i] = minElement;
        }
        
        cout << "ApÃ³s iteraÃ§Ã£o " << (i + 1) << ": ";
        printElements(arr, size, "");
    }
}

int main() {
    // Teste bÃ¡sico
    int numeros[] = {4, 2, 2, 8, 3, 3, 1};
    int tamanho = 7;
    
    stableSelectionSort(numeros, tamanho);
    
    // DemonstraÃ§Ã£o de estabilidade
    Element elementos[] = {
        {4, 0}, {2, 1}, {2, 2}, {8, 3}, {3, 4}, {3, 5}, {1, 6}
    };
    
    stableSelectionSortDemo(elementos, 7);
    
    return 0;
}
```

Como funciona a versÃ£o estÃ¡vel:

1. RotaÃ§Ã£o em vez de troca: Em vez de trocar o menor elemento com o primeiro, rotacionamos todos os elementos

2. Preserva ordem relativa: Elementos iguais mantÃªm sua ordem original

3. Complexidade: O(nÂ²) tempo, mas O(n) operaÃ§Ãµes de movimento por iteraÃ§Ã£o

4. Trade-off: Mais operaÃ§Ãµes de movimento, mas mantÃ©m estabilidade

DiferenÃ§a visual:

* Selection Sort normal: `[2a, 2b] â†’ [2b, 2a]` (nÃ£o estÃ¡vel)

* Selection Sort estÃ¡vel: `[2a, 2b] â†’ [2a, 2b]` (estÃ¡vel)



# ConclusÃ£o

O Selection Sort Ã© um excelente algoritmo para aprender os conceitos de ordenaÃ§Ã£o devido Ã  sua simplicidade e lÃ³gica intuitiva. Embora nÃ£o seja eficiente para arrays grandes, tem seu lugar em situaÃ§Ãµes especÃ­ficas onde a simplicidade e o baixo nÃºmero de trocas sÃ£o importantes.

O algoritmo demonstra claramente os conceitos de:

* DivisÃ£o de problema em subproblemas

* Invariantes de loop

* AnÃ¡lise de complexidade

* Trade-offs entre diferentes mÃ©tricas de performance



# Bubble Sort

## DiagramaÃ§Ã£o

![bubbleSort_annotated.png](images/bubbleSort_annotated.png)



