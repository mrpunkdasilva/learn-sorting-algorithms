# Learn Sorting Algorithm

## Entendendo Algoritmos de Ordena√ß√£o

Algoritmos de ordena√ß√£o funcionam como organizar uma bagun√ßa - voc√™ pega uma lista desordenada (como an√µes de tamanhos diferentes) e os coloca na ordem correta (do menor para o maior ou vice-versa).

Imagine esta fila de an√µes:

![Fila de an√£o](images/filadeanao.png)

## Conceitos Fundamentais Antes de Come√ßar

Antes de mergulharmos no algoritmo, vamos entender alguns conceitos b√°sicos:

### O que √© um Algoritmo?

Um algoritmo √© simplesmente uma lista de instru√ß√µes passo a passo para resolver um problema. √â como uma receita de bolo - voc√™ segue os passos na ordem certa para chegar ao resultado desejado.

Tip:

Exemplo pr√°tico: Para fazer um sandu√≠che, o algoritmo seria:

1. Pegue duas fatias de p√£o

2. Passe manteiga em uma fatia

3. Coloque o recheio

4. Feche com a outra fatia

### O que √© Itera√ß√£o?

Itera√ß√£o √© quando repetimos um conjunto de passos v√°rias vezes. √â como quando voc√™ escova os dentes - faz o mesmo movimento v√°rias vezes at√© limpar todos os dentes.

Em programa√ß√£o, quando dizemos:

* "Itera√ß√£o 1" = primeira vez que executamos os passos

* "Itera√ß√£o 2" = segunda vez que executamos os passos

* E assim por diante...

### O que √© Compara√ß√£o?

Comparar √© verificar qual elemento √© maior, menor ou igual ao outro. √â como quando voc√™ compara a altura de duas pessoas para saber quem √© mais alto.

## O B√°sico do Algoritmo de Ordena√ß√£o

Nosso algoritmo simples compara os elementos um a um, como quando voc√™ organiza suas roupas - pega cada pe√ßa e compara com as outras para ver qual √© maior ou menor.

## Como Funciona na Pr√°tica

Agora vamos ver como o algoritmo trabalha itera√ß√£o por itera√ß√£o (ou seja, repeti√ß√£o por repeti√ß√£o):

### Primeira Itera√ß√£o (1¬™ Repeti√ß√£o)

Comparo o primeiro an√£o ($i_1$) com o segundo an√£o ($j_1$).

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: Sim (verdadeiro) ‚Üí N√£o preciso trocar nada!

![Primeira itera√ß√£o](images/Primeiraiteracao.png)

### Segunda Itera√ß√£o (2¬™ Repeti√ß√£o)

Agora comparo $i_2$ com $j_2$.

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: N√£o (falso) ‚Üí Preciso trocar eles de lugar!

![Segunda itera√ß√£o](images/segundaint.png)

### Terceira Itera√ß√£o (3¬™ Repeti√ß√£o)

Comparo $i_{3}$ com $j_{3}$.

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: Sim (verdadeiro) ‚Üí N√£o preciso trocar nada!

![Terceira itera√ß√£o](images/terceiraint.png)

### Quarta Itera√ß√£o (4¬™ Repeti√ß√£o)

Comparo $i_{4}$ com $j_{4}$.

* Pergunta: O primeiro √© menor que o segundo?

* Resposta: N√£o (falso) ‚Üí Preciso trocar eles de lugar!

![Quarta itera√ß√£o](images/quartaiteracao.png)

### Quinta Itera√ß√£o (5¬™ e √öltima Repeti√ß√£o)

Agora todos os elementos j√° est√£o na ordem correta!

![Quinta intera√ß√£o](images/quintainteracao.png)
Tip:

Resumo: A cada itera√ß√£o, fazemos uma pergunta (compara√ß√£o) e tomamos uma decis√£o (trocar ou n√£o trocar). Repetimos isso at√© que tudo esteja organizado!

## O Que Todo Algoritmo de Ordena√ß√£o Precisa

Resumindo, todo algoritmo de ordena√ß√£o possui:

1. Entrada: A lista desordenada

2. Tipo de ordem: Crescente ou decrescente

3. Itera√ß√µes: Quantidade de repeti√ß√µes do processo

4. Compara√ß√µes: Crit√©rio para comparar os elementos

5. Sa√≠da: A lista organizada

```MERMAID
graph TD
    A[Algoritmo] --> B[Lista desordenada]
    A --> C[Ordem crescente/decrescente]
    A --> D[Repeti√ß√µes necess√°rias]
    A --> E[Como comparar]
    A --> F[Lista ordenada]
```

## Partindo para o C√≥digo

Agora vamos ver como transformar nossa l√≥gica em c√≥digo C++. Vou explicar cada parte:

### Conceitos B√°sicos Antes do C√≥digo

#### O que √© um Array?

Um array √© como uma fileira de caixas numeradas onde guardamos valores. Cada caixa tem um n√∫mero (√≠ndice) e pode guardar um valor.

```
Array: [5] [2] [8] [1] [9]
√çndice: 0   1   2   3   4
```

#### O que √© um Loop For?

Um loop for √© uma forma de repetir uma a√ß√£o v√°rias vezes. √â como dizer: "fa√ßa isso 10 vezes" ou "fa√ßa isso para cada elemento da lista".

```CPLUSPLUS
for (int i = 0; i < 5; i++) {
    // Este c√≥digo vai executar 5 vezes
    // i vai valer: 0, 1, 2, 3, 4
}
```

### O C√≥digo Completo Explicado

```CPLUSPLUS
#include <iostream>  // Para usar cout e cin (entrada e sa√≠da)
#include <cstdlib>   // Para usar rand() (n√∫meros aleat√≥rios)
#define MAX_SIZE 100 // Define o tamanho m√°ximo do array
using namespace std;

int main()
{
    // PARTE 1: DECLARA√á√ÉO DAS VARI√ÅVEIS
    int n;                // Quantos n√∫meros vamos ordenar
    int array[MAX_SIZE];  // Nossa lista de n√∫meros (o array)

    // PARTE 2: ENTRADA DE DADOS
    cout << "Digite quantos n√∫meros voc√™ quer ordenar: " << endl;
    cin >> n;  // L√™ a resposta do usu√°rio

    // PARTE 3: PREENCHIMENTO COM N√öMEROS ALEAT√ìRIOS
    cout << "Gerando " << n << " n√∫meros aleat√≥rios..." << endl;
    for (int i = 0; i < n; i++) {
        array[i] = rand() % 100;  // Gera n√∫mero entre 0 e 99
    }

    // PARTE 4: MOSTRA A LISTA BAGUN√áADA
    cout << "\nLista original (bagun√ßada): ";
    for (int i = 0; i < n; i++) {
        cout << "[" << array[i] << "] ";
    }
    cout << endl << endl;

    // PARTE 5: O ALGORITMO DE ORDENA√á√ÉO (O CORA√á√ÉO DO PROGRAMA!)
    cout << "Iniciando ordena√ß√£o..." << endl;
    
    // Loop externo: seleciona cada elemento (itera√ß√£o principal)
    for (int i = 0; i < n; i++) {
        
        // Loop interno: compara com os elementos seguintes
        for (int j = i + 1; j < n; j++) {
            
            // Mostra o que est√° sendo comparado
            cout << "Comparando: " << array[i] << " com " << array[j];
            
            // AQUI √â ONDE A M√ÅGICA ACONTECE!
            // Se o primeiro for MENOR que o segundo, trocamos
            if (array[i] < array[j]) {
                cout << " ‚Üí Trocando!" << endl;
                
                // PROCESSO DE TROCA (como trocar duas cartas de lugar)
                int temp = array[i];  // Guarda o primeiro valor
                array[i] = array[j];  // P√µe o segundo no lugar do primeiro
                array[j] = temp;      // P√µe o primeiro no lugar do segundo
            } else {
                cout << " ‚Üí N√£o precisa trocar" << endl;
            }
        }
    }

    // PARTE 6: MOSTRA O RESULTADO FINAL
    cout << "\n" << "=" << endl;
    cout << "Lista ordenada (maior para menor): ";
    for (int i = 0; i < n; i++) {
        cout << "[" << array[i] << "] ";
    }
    cout << endl;

    return 0;  // Programa terminou com sucesso
}
```

### Pontos Importantes Para Entender:

#### 

1. Como Funciona o rand()

* `rand()` gera n√∫meros aleat√≥rios gigantes

* `rand() % 100` limita os n√∫meros entre 0 e 99 (mais f√°cil de trabalhar)

#### 

2. Por que Dois Loops For?

* Loop externo (i): Escolhe cada elemento da lista, um por vez

* Loop interno (j): Compara esse elemento com todos os outros que v√™m depois

* √â como comparar cada an√£o com todos os outros an√µes

#### 

3. Como Funciona a Troca (Swap)?

Imagine que voc√™ tem duas cartas e quer trocar elas de lugar:

```CPLUSPLUS
int temp = array[i];  // Guardo a primeira carta na m√£o
array[i] = array[j];  // Ponho a segunda carta no lugar da primeira
array[j] = temp;      // Ponho a primeira carta (que estava na m√£o) no lugar da segunda
```

#### 

4. Mudando a Ordem

* Para ordem DECRESCENTE (maior ‚Üí menor): use `if (array[i] < array[j])`

* Para ordem CRESCENTE (menor ‚Üí maior): use `if (array[i] > array[j])`

### Importante Saber

Este algoritmo se chama Selection Sort (Ordena√ß√£o por Sele√ß√£o). Ele n√£o √© o mais r√°pido para listas muito grandes, mas √© perfeito para aprender porque:

* ‚úÖ √â f√°cil de entender

* ‚úÖ Mostra claramente como funciona a ordena√ß√£o

* ‚úÖ Usa conceitos b√°sicos que voc√™ vai usar sempre

Tip:

Dica: Execute o c√≥digo algumas vezes com n√∫meros pequenos (como 5 elementos) para ver exatamente como ele funciona!



# Selection Sort

## O que √© Selection Sort?

O Selection Sort √© um algoritmo de ordena√ß√£o simples e intuitivo que funciona dividindo o array em duas partes:

* Parte ordenada: Localizada no in√≠cio do array (inicialmente vazia)

* Parte n√£o ordenada: Localizada no final do array (inicialmente todo o array)

## Como funciona?

O algoritmo funciona da seguinte forma:

1. Encontra o menor elemento da parte n√£o ordenada

2. Troca esse elemento com o primeiro elemento da parte n√£o ordenada

3. Expande a parte ordenada em uma posi√ß√£o

4. Repete o processo at√© que todo o array esteja ordenado

## Diagrama√ß√£o

![selectionSort_annotated.png](images/selectionSort_annotated.png)

## Exemplo Visual

Considerando o array: `[64, 25, 12, 22, 11]`

Itera√ß√£o 1:

* Parte ordenada: `[]`

* Parte n√£o ordenada: `[64, 25, 12, 22, 11]`

* Menor elemento: `11` (posi√ß√£o 4)

* Troca: `11` ‚Üî `64`

* Resultado: `[11, 25, 12, 22, 64]`

Itera√ß√£o 2:

* Parte ordenada: `[11]`

* Parte n√£o ordenada: `[25, 12, 22, 64]`

* Menor elemento: `12` (posi√ß√£o 2)

* Troca: `12` ‚Üî `25`

* Resultado: `[11, 12, 25, 22, 64]`

Itera√ß√£o 3:

* Parte ordenada: `[11, 12]`

* Parte n√£o ordenada: `[25, 22, 64]`

* Menor elemento: `22` (posi√ß√£o 3)

* Troca: `22` ‚Üî `25`

* Resultado: `[11, 12, 22, 25, 64]`

Itera√ß√£o 4:

* Parte ordenada: `[11, 12, 22]`

* Parte n√£o ordenada: `[25, 64]`

* Menor elemento: `25` (j√° na posi√ß√£o correta)

* Sem troca necess√°ria

* Resultado: `[11, 12, 22, 25, 64]`



# Implementa√ß√£o

Nossa implementa√ß√£o educativa inclui sa√≠das detalhadas para ajudar no aprendizado.

Voc√™ pode encontrar uma implementa√ß√£o completa e educativa do Selection Sort em:

## Fun√ß√£o Principal - Selection Sort Algorithm

```CPP
void selectionSortAlgorithm(int dataArray[], int arraySize)
{
    cout << "========================================" << endl;
    cout << "STARTING SELECTION SORT ALGORITHM" << endl;
    cout << "========================================" << endl;
    cout << "Initial array: ";
    for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
        cout << dataArray[displayIndex] << " ";
    }
    cout << endl << endl;

    int totalNumberOfSwaps = 0;

    for (int currentPosition = 0; currentPosition < arraySize - 1; currentPosition++)
    {
        cout << ">>> ITERATION " << (currentPosition + 1) << " <<<" << endl;
        cout << "Looking for smallest element for position " << currentPosition << endl;
        
        int smallestElementIndex = findSmallestElementIndex(dataArray, currentPosition, arraySize - 1);

        if (currentPosition != smallestElementIndex) {
            cout << "Smallest element is at position " << smallestElementIndex << ", need to swap with position " << currentPosition << endl;
            swapElements(dataArray, currentPosition, smallestElementIndex);
            totalNumberOfSwaps++;
        } else {
            cout << "Smallest element is already in correct position (" << currentPosition << "), no swap needed" << endl;
        }

        cout << "Array state after iteration " << (currentPosition + 1) << ": ";
        for(int displayIndex = 0; displayIndex < arraySize; displayIndex++) {
            if (displayIndex <= currentPosition) {
                cout << "[" << dataArray[displayIndex] << "] "; // Already sorted elements
            } else {
                cout << dataArray[displayIndex] << " ";        // Not yet sorted elements
            }
        }
        cout << endl;
        cout << "Elements sorted: " << (currentPosition + 1) << "/" << arraySize << endl;
        cout << "--------------------------------" << endl;
    }

    cout << "========================================" << endl;
    cout << "SELECTION SORT ALGORITHM COMPLETED!" << endl;
    cout << "Total number of swaps performed: " << totalNumberOfSwaps << endl;
    cout << "========================================" << endl;
}
```

## Fun√ß√£o para Encontrar o Menor Elemento

```CPP
int findSmallestElementIndex(int dataArray[], int startIndex, int endIndex)
{
    cout << "--- Searching for smallest element in range [" << startIndex << ", " << endIndex << "] ---" << endl;
    int currentIndex = startIndex;
    int smallestIndex = currentIndex;
    int numberOfComparisons = 0;

    cout << "Initial element for comparison: dataArray[" << smallestIndex << "] = " << dataArray[smallestIndex] << endl;

    while (currentIndex <= endIndex)
    {
        cout << "Comparing dataArray[" << currentIndex << "] = " << dataArray[currentIndex] << " with current smallest dataArray[" << smallestIndex << "] = " << dataArray[smallestIndex];
        numberOfComparisons++;
        
        if (dataArray[currentIndex] < dataArray[smallestIndex])
        {
            cout << " -> " << dataArray[currentIndex] << " is smaller! New smallest element found at position " << currentIndex << endl;
            smallestIndex = currentIndex;
        }
        else
        {
            cout << " -> " << dataArray[currentIndex] << " >= " << dataArray[smallestIndex] << ", keeping current smallest" << endl;
        }

        currentIndex++;
    }

    cout << "Smallest element found: " << dataArray[smallestIndex] << " at position " << smallestIndex << " (after " << numberOfComparisons << " comparisons)" << endl;
    return smallestIndex;
}
```

## Fun√ß√£o para Trocar Elementos

```CPP
void swapElements(int dataArray[], int firstPosition, int secondPosition)
{
    cout << "  -> Swapping elements: " << dataArray[firstPosition] << " (position " << firstPosition << ") <-> " << dataArray[secondPosition] << " (position " << secondPosition << ")" << endl;
    int temporaryValue = dataArray[firstPosition];
    dataArray[firstPosition] = dataArray[secondPosition];
    dataArray[secondPosition] = temporaryValue;
    cout << "  -> After swap: position " << firstPosition << " = " << dataArray[firstPosition] << ", position " << secondPosition << " = " << dataArray[secondPosition] << endl;
}
```

## Caracter√≠sticas do Algoritmo

### Complexidade de Tempo

* Melhor caso: O(n¬≤) - Mesmo que o array j√° esteja ordenado

* Caso m√©dio: O(n¬≤) - Comportamento t√≠pico

* Pior caso: O(n¬≤) - Array ordenado inversamente

### Complexidade de Espa√ßo

* O(1) - Algoritmo in-place, usa apenas mem√≥ria constante adicional

### Propriedades Importantes

| Propriedade |Valor |
----------------------
| Est√°vel |‚ùå N√£o |
| In-place |‚úÖ Sim |
| Adaptivo |‚ùå N√£o |
| Compara√ß√µes |O(n¬≤) |
| Trocas |O(n) |



# Por que o Selection Sort N√ÉO √© Est√°vel?

## O que significa "Estabilidade" em algoritmos de ordena√ß√£o?

Um algoritmo de ordena√ß√£o √© est√°vel quando mant√©m a ordem relativa dos elementos que possuem valores iguais. Ou seja, se dois elementos t√™m o mesmo valor, aquele que aparece primeiro no array original deve aparecer primeiro no array ordenado.

## Exemplo Pr√°tico de Instabilidade

Considere um array de cartas onde cada carta tem um valor e um naipe:

Array inicial: `[5‚ô†, 3‚ô¶, 5‚ô•, 2‚ô£, 3‚ô†]`

Vamos ordenar por valor num√©rico apenas, ignorando o naipe:

### ‚úÖ Ordena√ß√£o Est√°vel (esperada):

`[2‚ô£, 3‚ô¶, 3‚ô†, 5‚ô†, 5‚ô•]`

* Note que `3‚ô¶` vem antes de `3‚ô†` (mant√©m ordem original)

* E `5‚ô†` vem antes de `5‚ô•` (mant√©m ordem original)

### ‚ùå Selection Sort (inst√°vel):

`[2‚ô£, 3‚ô†, 3‚ô¶, 5‚ô•, 5‚ô†]`

* `3‚ô†` agora vem antes de `3‚ô¶` (ordem alterada!)

* `5‚ô•` agora vem antes de `5‚ô†` (ordem alterada!)

## Por que isso acontece no Selection Sort?

O Selection Sort troca elementos distantes entre si, o que pode "pular" sobre elementos iguais e alterar sua ordem relativa.

### Demonstra√ß√£o com n√∫meros simples:

Array inicial: `[4, 2, 4, 1, 3]`

* Para distinguir, vamos chamar: `[4a, 2, 4b, 1, 3]`

Execu√ß√£o do Selection Sort:

Itera√ß√£o 1:

* Procura menor elemento: `1` (posi√ß√£o 3)

* Troca: `4a` ‚Üî `1`

* Resultado: `[1, 2, 4b, 4a, 3]`

Warning:

Observe: `4b` agora vem antes de `4a`!

Itera√ß√£o 2:

* Procura menor na parte n√£o ordenada `[2, 4b, 4a, 3]`: `2` j√° est√° correto

* Sem troca

* Resultado: `[1, 2, 4b, 4a, 3]`

Itera√ß√£o 3:

* Procura menor na parte n√£o ordenada `[4b, 4a, 3]`: `3` (posi√ß√£o 4)

* Troca: `4b` ‚Üî `3`

* Resultado: `[1, 2, 3, 4a, 4b]`

Array final: `[1, 2, 3, 4a, 4b]`

## O Problema da "Troca Distante"

```
Array: [4a, 2, 4b, 1, 3]
        ‚Üë           ‚Üë
        |___________|
     Troca distante que "pula"
     sobre 4b, alterando a ordem!
```

Quando o Selection Sort encontra o menor elemento em uma posi√ß√£o distante, ele o troca diretamente com a posi√ß√£o atual, pulando sobre todos os elementos intermedi√°rios, incluindo aqueles que t√™m o mesmo valor.

## Impacto Pr√°tico da Instabilidade

A instabilidade pode ser problem√°tica em situa√ß√µes reais:

1. Ordena√ß√£o de registros de funcion√°rios por sal√°rio:

* Se dois funcion√°rios t√™m o mesmo sal√°rio, voc√™ pode querer manter a ordem original (ex: por data de contrata√ß√£o)

2. Classifica√ß√£o de produtos por pre√ßo:

* Produtos com mesmo pre√ßo podem ter diferentes prioridades de exibi√ß√£o

3. Ordena√ß√£o de notas de alunos:

* Alunos com a mesma nota podem estar em ordem alfab√©tica inicialmente

## Como tornar o Selection Sort est√°vel?

√â poss√≠vel modificar o Selection Sort para ser est√°vel, mas isso aumenta a complexidade:

```CPP
// Vers√£o est√°vel (menos eficiente)
void stableSelectionSort(int arr[], int n) {
    for (int i = 0; i < n-1; i++) {
        int minIdx = i;
        for (int j = i+1; j < n; j++) {
            if (arr[j] < arr[minIdx]) {
                minIdx = j;
            }
        }
        
        // Em vez de trocar diretamente, 
        // desloca todos os elementos entre i e minIdx
        int key = arr[minIdx];
        while (minIdx > i) {
            arr[minIdx] = arr[minIdx-1];
            minIdx--;
        }
        arr[i] = key;
    }
}
```

Warning:

Mas isso aumenta a complexidade de trocas de O(n) para O(n¬≤)!

## Visualiza√ß√£o da Instabilidade - "Rotatividade"

O conceito de "rotatividade" que voc√™ mencionou refere-se √† forma como os elementos "giram" ou alteram suas posi√ß√µes relativas durante as trocas distantes:

```
Estado inicial: [4a, 2, 4b, 1, 3]
                 ‚ñ≤              ‚ñ≤
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò Troca distante na itera√ß√£o 1

Ap√≥s troca:     [1, 2, 4b, 4a, 3]
                        ‚ñ≤   ‚ñ≤
                     4b "rotacionou" para frente de 4a

Estado inicial: [A, B, C, D] (onde A = D em valor)
Ap√≥s Selection: [D, B, C, A] (A e D trocaram posi√ß√µes!)
                 ‚ñ≤        ‚ñ≤
                 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò "Rotatividade" - ordem relativa invertida
```

## Compara√ß√£o Visual: Est√°vel vs Inst√°vel

### Algoritmo Est√°vel (ex: Insertion Sort):

```
[3a, 1, 3b, 2] ‚Üí [1, 2, 3a, 3b] ‚úÖ Ordem mantida
 ‚ñ≤      ‚ñ≤                ‚ñ≤   ‚ñ≤
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò                ‚îî‚îÄ‚îÄ‚îÄ‚îò 3a ainda vem antes de 3b
```

### Selection Sort (Inst√°vel):

```
[3a, 1, 3b, 2] ‚Üí [1, 2, 3b, 3a] ‚ùå Ordem alterada!
 ‚ñ≤      ‚ñ≤               ‚ñ≤   ‚ñ≤
 ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò               ‚îî‚îÄ‚îÄ‚îÄ‚îò 3b agora vem antes de 3a
```

## Resumo: Por que Selection Sort √© Inst√°vel

* Trocas distantes: Elementos s√£o trocados atrav√©s de grandes dist√¢ncias

* Pula elementos: Ignora elementos iguais no meio do caminho

* Foco apenas no valor: N√£o considera a posi√ß√£o original dos elementos iguais

* Prioriza efici√™ncia: A vers√£o est√°vel seria muito menos eficiente

* Rotatividade: Elementos iguais podem "rotacionar" suas posi√ß√µes relativas



# Vantagens vs. Disvantagens

## Vantagens

* ‚úÖ Simples de implementar e entender

* ‚úÖ Poucas trocas: M√°ximo de n-1 trocas

* ‚úÖ In-place: N√£o requer mem√≥ria adicional

* ‚úÖ Funciona bem com arrays pequenos

* ‚úÖ Eficiente quando opera√ß√µes de escrita s√£o caras

## Desvantagens

* ‚ùå Complexidade O(n¬≤): Ineficiente para arrays grandes

* ‚ùå N√£o √© est√°vel: Pode alterar a ordem relativa de elementos iguais

* ‚ùå N√£o √© adaptivo: N√£o aproveita arrays parcialmente ordenados

* ‚ùå Sempre faz n-1 passadas: Mesmo que o array j√° esteja ordenado



# Quando Usar?

O Selection Sort √© adequado quando:

* Arrays pequenos (< 50 elementos)

* Opera√ß√µes de escrita s√£o caras (ex: mem√≥ria flash)

* Simplicidade √© mais importante que efici√™ncia

* Mem√≥ria √© limitada (algoritmo in-place)



# Compara√ß√£o com Outros Algoritmos

| Algoritmo |Melhor Caso |Caso M√©dio |Pior Caso |Est√°vel |Trocas |
------------------------------------------------------------------
| Selection Sort |O(n¬≤) |O(n¬≤) |O(n¬≤) |‚ùå |O(n) |
| Bubble Sort |O(n) |O(n¬≤) |O(n¬≤) |‚úÖ |O(n¬≤) |
| Insertion Sort |O(n) |O(n¬≤) |O(n¬≤) |‚úÖ |O(n¬≤) |
| Merge Sort |O(n log n) |O(n log n) |O(n log n) |‚úÖ |- |
| Quick Sort |O(n log n) |O(n log n) |O(n¬≤) |‚ùå |O(n log n) |



# Varia√ß√µes do Selection Sort

## 1. Selection Sort Bidirecional

Encontra simultaneamente o menor e maior elemento em cada passada, colocando-os nas extremidades.

## 2. Selection Sort Recursivo

Implementa√ß√£o recursiva que ordena recursivamente subarray ap√≥s colocar o menor elemento na primeira posi√ß√£o.

## 3. Selection Sort Est√°vel

Modifica√ß√£o que mant√©m a estabilidade trocando elementos apenas quando necess√°rio.



# Exerc√≠cios Pr√°ticos

## Exerc√≠cio 1: Implementa√ß√£o B√°sica

Implemente o Selection Sort para ordenar um array de strings por ordem alfab√©tica.

### üí° Solu√ß√£o do Exerc√≠cio 1

```CPP
#include <iostream>
#include <string>
using namespace std;

// Fun√ß√£o para encontrar o √≠ndice da menor string
int findSmallestStringIndex(string arr[], int start, int end) {
    int smallestIndex = start;
    
    for (int i = start + 1; i <= end; i++) {
        if (arr[i] < arr[smallestIndex]) {
            smallestIndex = i;
        }
    }
    
    return smallestIndex;
}

// Fun√ß√£o para trocar duas strings
void swapStrings(string arr[], int pos1, int pos2) {
    string temp = arr[pos1];
    arr[pos1] = arr[pos2];
    arr[pos2] = temp;
}

// Selection Sort para strings
void selectionSortStrings(string arr[], int size) {
    cout << "Ordenando strings por ordem alfab√©tica:" << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "\nItera√ß√£o " << (i + 1) << ":" << endl;
        
        int smallestIndex = findSmallestStringIndex(arr, i, size - 1);
        
        if (i != smallestIndex) {
            cout << "Trocando \"" << arr[i] << "\" com \"" << arr[smallestIndex] << "\"" << endl;
            swapStrings(arr, i, smallestIndex);
        } else {
            cout << "\"" << arr[i] << "\" j√° est√° na posi√ß√£o correta" << endl;
        }
        
        // Mostrar estado atual
        cout << "Array atual: ";
        for (int j = 0; j < size; j++) {
            if (j <= i) {
                cout << "[" << arr[j] << "] ";
            } else {
                cout << arr[j] << " ";
            }
        }
        cout << endl;
    }
}

// Exemplo de uso
int main() {
    string frutas[] = {"banana", "ma√ß√£", "laranja", "uva", "abacaxi"};
    int tamanho = 5;
    
    cout << "Array inicial: ";
    for (int i = 0; i < tamanho; i++) {
        cout << frutas[i] << " ";
    }
    cout << endl;
    
    selectionSortStrings(frutas, tamanho);
    
    cout << "\nArray final ordenado: ";
    for (int i = 0; i < tamanho; i++) {
        cout << frutas[i] << " ";
    }
    cout << endl;
    
    return 0;
}
```

Pontos importantes:

* Usamos o operador `<` para compara√ß√£o lexicogr√°fica de strings

* A l√≥gica √© a mesma do Selection Sort para n√∫meros

* Strings s√£o ordenadas alfabeticamente (A-Z)

## Exerc√≠cio 2: Contagem de Opera√ß√µes

Modifique o algoritmo para contar o n√∫mero de compara√ß√µes e trocas realizadas.

### üí° Solu√ß√£o do Exerc√≠cio 2

```CPP
#include <iostream>
using namespace std;

// Estrutura para armazenar estat√≠sticas
struct SortStatistics {
    int comparisons;
    int swaps;
    
    SortStatistics() : comparisons(0), swaps(0) {}
};

// Fun√ß√£o para encontrar o menor elemento com contagem de compara√ß√µes
int findSmallestWithStats(int arr[], int start, int end, SortStatistics& stats) {
    int smallestIndex = start;
    
    for (int i = start + 1; i <= end; i++) {
        stats.comparisons++; // Incrementa contador de compara√ß√µes
        
        if (arr[i] < arr[smallestIndex]) {
            smallestIndex = i;
        }
    }
    
    return smallestIndex;
}

// Fun√ß√£o para trocar elementos com contagem
void swapWithStats(int arr[], int pos1, int pos2, SortStatistics& stats) {
    if (pos1 != pos2) {
        stats.swaps++; // Incrementa contador de trocas
        
        int temp = arr[pos1];
        arr[pos1] = arr[pos2];
        arr[pos2] = temp;
        
        cout << "  Troca #" << stats.swaps << ": " << arr[pos1] 
             << " <-> " << arr[pos2] << endl;
    }
}

// Selection Sort com estat√≠sticas
void selectionSortWithStats(int arr[], int size) {
    SortStatistics stats;
    
    cout << "=== SELECTION SORT COM ESTAT√çSTICAS ===" << endl;
    cout << "Array inicial: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "Itera√ß√£o " << (i + 1) << ":" << endl;
        
        int smallestIndex = findSmallestWithStats(arr, i, size - 1, stats);
        
        cout << "  Menor elemento: " << arr[smallestIndex] 
             << " (posi√ß√£o " << smallestIndex << ")" << endl;
        
        swapWithStats(arr, i, smallestIndex, stats);
        
        cout << "  Compara√ß√µes nesta itera√ß√£o: " 
             << (stats.comparisons - (i > 0 ? (size - i) : 0)) << endl;
        cout << "  Array atual: ";
        for (int j = 0; j < size; j++) {
            if (j <= i) {
                cout << "[" << arr[j] << "] ";
            } else {
                cout << arr[j] << " ";
            }
        }
        cout << endl << endl;
    }
    
    // Exibir estat√≠sticas finais
    cout << "========== ESTAT√çSTICAS FINAIS ==========" << endl;
    cout << "Total de compara√ß√µes: " << stats.comparisons << endl;
    cout << "Total de trocas: " << stats.swaps << endl;
    cout << "Efici√™ncia de trocas: " << stats.swaps << "/" << (size - 1) 
         << " (" << (stats.swaps * 100.0 / (size - 1)) << "%)" << endl;
    cout << "Compara√ß√µes te√≥ricas O(n¬≤): " << (size * (size - 1) / 2) << endl;
    cout << "Compara√ß√µes reais vs te√≥ricas: " << stats.comparisons 
         << "/" << (size * (size - 1) / 2) << endl;
}

// Exemplo de uso
int main() {
    int numeros[] = {64, 34, 25, 12, 22, 11, 90};
    int tamanho = 7;
    
    selectionSortWithStats(numeros, tamanho);
    
    return 0;
}
```

An√°lise das Estat√≠sticas:

* Compara√ß√µes: Sempre n(n-1)/2 independente da entrada

* Trocas: No m√°ximo n-1, pode ser menor se alguns elementos j√° est√£o no lugar

* Efici√™ncia: Mostra quantas trocas foram realmente necess√°rias

## Exerc√≠cio 3: Vers√£o Est√°vel

Implemente uma vers√£o est√°vel do Selection Sort.

### üí° Solu√ß√£o do Exerc√≠cio 3

```CPP
#include <iostream>
using namespace std;

// Fun√ß√£o para rotacionar elementos para manter estabilidade
void rotateRight(int arr[], int start, int end) {
    int temp = arr[end];
    for (int i = end; i > start; i--) {
        arr[i] = arr[i - 1];
    }
    arr[start] = temp;
}

// Selection Sort Est√°vel
void stableSelectionSort(int arr[], int size) {
    cout << "=== SELECTION SORT EST√ÅVEL ===" << endl;
    cout << "Array inicial: ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl << endl;
    
    for (int i = 0; i < size - 1; i++) {
        cout << "Itera√ß√£o " << (i + 1) << ":" << endl;
        
        // Encontrar o menor elemento na parte n√£o ordenada
        int minIndex = i;
        for (int j = i + 1; j < size; j++) {
            if (arr[j] < arr[minIndex]) {
                minIndex = j;
            }
        }
        
        cout << "  Menor elemento: " << arr[minIndex] 
             << " (posi√ß√£o " << minIndex << ")" << endl;
        
        // Em vez de trocar, rotacionar para manter estabilidade
        if (minIndex != i) {
            cout << "  Rotacionando elementos da posi√ß√£o " << i 
                 << " at√© " << minIndex << endl;
            
            int minValue = arr[minIndex];
            rotateRight(arr, i, minIndex);
            
            cout << "  Elemento " << minValue 
                 << " movido para posi√ß√£o " << i << " mantendo ordem relativa" << endl;
        } else {
            cout << "  Elemento j√° est√° na posi√ß√£o correta" << endl;
        }
        
        cout << "  Array atual: ";
        for (int j = 0; j < size; j++) {
            if (j <= i) {
                cout << "[" << arr[j] << "] ";
            } else {
                cout << arr[j] << " ";
            }
        }
        cout << endl << endl;
    }
    
    cout << "Array final ordenado (est√°vel): ";
    for (int i = 0; i < size; i++) {
        cout << arr[i] << " ";
    }
    cout << endl;
}

// Vers√£o para demonstrar estabilidade com pares (valor, √≠ndice original)
struct Element {
    int value;
    int originalIndex;
};

void printElements(Element arr[], int size, string label) {
    cout << label;
    for (int i = 0; i < size; i++) {
        cout << "(" << arr[i].value << "," << arr[i].originalIndex << ") ";
    }
    cout << endl;
}

void stableSelectionSortDemo(Element arr[], int size) {
    cout << "\n=== DEMONSTRA√á√ÉO DE ESTABILIDADE ===" << endl;
    printElements(arr, size, "Array inicial: ");
    
    for (int i = 0; i < size - 1; i++) {
        // Encontrar o menor elemento
        int minIndex = i;
        for (int j = i + 1; j < size; j++) {
            if (arr[j].value < arr[minIndex].value) {
                minIndex = j;
            }
        }
        
        // Rotacionar para manter ordem relativa
        if (minIndex != i) {
            Element minElement = arr[minIndex];
            for (int k = minIndex; k > i; k--) {
                arr[k] = arr[k - 1];
            }
            arr[i] = minElement;
        }
        
        cout << "Ap√≥s itera√ß√£o " << (i + 1) << ": ";
        printElements(arr, size, "");
    }
}

int main() {
    // Teste b√°sico
    int numeros[] = {4, 2, 2, 8, 3, 3, 1};
    int tamanho = 7;
    
    stableSelectionSort(numeros, tamanho);
    
    // Demonstra√ß√£o de estabilidade
    Element elementos[] = {
        {4, 0}, {2, 1}, {2, 2}, {8, 3}, {3, 4}, {3, 5}, {1, 6}
    };
    
    stableSelectionSortDemo(elementos, 7);
    
    return 0;
}
```

Como funciona a vers√£o est√°vel:

1. Rota√ß√£o em vez de troca: Em vez de trocar o menor elemento com o primeiro, rotacionamos todos os elementos

2. Preserva ordem relativa: Elementos iguais mant√™m sua ordem original

3. Complexidade: O(n¬≤) tempo, mas O(n) opera√ß√µes de movimento por itera√ß√£o

4. Trade-off: Mais opera√ß√µes de movimento, mas mant√©m estabilidade

Diferen√ßa visual:

* Selection Sort normal: `[2a, 2b] ‚Üí [2b, 2a]` (n√£o est√°vel)

* Selection Sort est√°vel: `[2a, 2b] ‚Üí [2a, 2b]` (est√°vel)



# Conclus√£o

O Selection Sort √© um excelente algoritmo para aprender os conceitos de ordena√ß√£o devido √† sua simplicidade e l√≥gica intuitiva. Embora n√£o seja eficiente para arrays grandes, tem seu lugar em situa√ß√µes espec√≠ficas onde a simplicidade e o baixo n√∫mero de trocas s√£o importantes.

O algoritmo demonstra claramente os conceitos de:

* Divis√£o de problema em subproblemas

* Invariantes de loop

* An√°lise de complexidade

* Trade-offs entre diferentes m√©tricas de performance



# Bubble Sort

## Diagrama√ß√£o

![bubbleSort_annotated.png](images/bubbleSort_annotated.png)



